'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/Ch0/01_devcpp/','title':"01 Devcpp",'content':"Dev-C++ Dev-C++是由Bloodshed開發的一套IDE，不過自2005年初後，便不再更新，2011年由Orwell接手維護非官方版本，這邊安裝教學使用 Orwell Dev-C++ 5.11。\n目前仍有不少高中、大學的用其作為C語言授課用程式，但由於功能不甚完備，故在此不推薦使用。\n 適用平台：Windows Only (Windows XP或以上)\n 安裝   先到 Orwell Dev-C++ 下載安裝程式。\n  執行安裝程式。\n  如果出現這個畫面，請按執行(Run)。\n  選「English」，按下OK。\n  按下「I Agree」。\n  按下「Next」。\n  按下「Install」。\n  按下「Finish」。\n到這個步驟，你的Dev-C++就已經安裝完成了。\n  第一次開啟 第一次開啟需要進行一些設定：\n  選擇「Chinese(TW)」，並按下「Next」。\n  按下「下一步」。\n  按下「完成」。\n  當你看到下面這個畫面，就代表你的Dev-C++設定完畢！\n這個步驟只需要在安裝後的第一次開起執行，之後不會再次遇到這個畫面。\n編譯及執行   開新檔案。\n  撰寫完畢之後，按下上方的按鈕。\n  如果出現黑色主控台視窗，即表示撰寫正確，程式正常開始執行。\n  "});index.add({'id':1,'href':'/docs/Ch0/02_codeblocks/','title':"02 Codeblocks",'content':"Code::Blocks Code::Blocks是本次教材中推薦使用的IDE，安裝教學使用Code::Blocks 16.01示範。\n 適用平台：Windows, Linux, Mac OS X\n Windows 安裝   先到 Code::Blocks官網 下載 WIndows 版本的 Code::Blocks 安裝程式。\n請點選 SourceForge.net 下載。   請耐心的等待下載。   直接點兩下開啟安裝程式，你可能會看到未知發佈者警告，請選 Run。   請選「下一步」。   請「同意(Agree)」服務條款。   全選，「下一步」。   安裝程式會詢問你是否要執行 Code::Blocks，你可以自行決定。\n不過這裡我們選擇「是」。   請選「下一步」。   請選「完成」。   Linux 安裝  示範平台：Ubuntu 16.10\n 大部分的套件管理程式都有收錄 Code::Blocks 的最新版本，我們可以直接用 apt-get 來安裝。\n$ sudo apt-get install codeblocks 第一次啟動  程式會問你未來是否要用 Code::Blocks 來開啟 C/C++ 檔案，你可以自行決定。\n在這邊我們選第三項「是，關聯所有 C/C++ 檔案」。   "});index.add({'id':2,'href':'/docs/Ch0/03_visualstudio/','title':"03 Visualstudio",'content':"Visual Studio Visual Studio 是 Microsoft 開發的一套非常強大的IDE\n這邊的教學使用 Visual Studio Community 2015\n 適用平台：Windows Only (Windows 7 SP1或以上)\n其他平台可以參考Visual Studio Code，但是功能上有差異\n 備註：\n 安裝會需要大量的網路與硬碟空間，視選擇的套件而定 會需要一個 Microsoft 的帳號啟動軟體(免費的)  安裝   先到 https://www.visualstudio.com/zh-tw/products/visual-studio-community-vs.aspx\n點選「下載 Community 2015」\n  執行安裝程式\n  跳出安全性警告，確定發行者名稱是否跟圖片相同，點選「執行」\n  安裝程式準備中\u0026hellip;\n  「選擇安裝類型」為「自訂」，點「下一步」\n  因為要寫 C / C++ 程式\n所以勾選「 Visual C++」，點選「下一步」\n  點選「安裝」\n  安裝中\u0026hellip;\u0026hellip;(要一段時間，可以去喝個咖啡)\n  安裝完成，點選「啟動」\n  點選「登入」，登入自己的 Microsoft 帳號(第一次啟動會需要)\n  登入完成後，可以看到啟動的 Visual Studio Community 2015\n  設定 這邊基本上教大家調字體大小，其他的設定可以自行摸索\n  點選工具列「工具」/「選項」\n  左側選到「環境」/「字型與色彩」\n將「大小」調至「14」(這邊可以依個人喜好調整)\n按下「確定」   建立第一個專案   點選工具列「檔案」/「新增」/「專案」\n  選擇「Win32 主控台應用程式」\n專案名稱、位置、方案名稱可以自己設定\n按下「確定」\n  按下「下一步」\n  勾選「空專案」\n取消勾選「安全性開發週期(SDL)檢查」\n按下「完成」\n  在右側的「方案總管」中\n在「原始程式檔」按右鍵\n選擇「加入」/「新增項目」\n  選擇「C++檔」\n檔名可以自訂，按下「新增」   打上下面示範用程式碼\n  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world\u0026#34;); return 0; }   按下「本機 Windows 偵測工具」\n點選「是」   順利的話，程式會順利的執行\n然後順利的結束\n  要看到執行的結果\n需要使用中斷點\n請在第 5 行左邊灰色處點一下，出現紅色圓圈   按下「本機 Windows 偵測工具」\n程式準備要執行第 5 行時會停下來\n此時就可以看到輸出的結果   其他 剛剛我們是新增專案，所以下次繼續寫時，要開啟專案(不是檔案喔)\n方法一： 直接點ConsoleApplication1.sln兩下 方法二： 或是用「檔案」/「開啟」/「專案/方案」\n然後開啟ConsoleApplication1.sln "});index.add({'id':3,'href':'/docs/Ch0/Intro/','title':"Intro",'content':"Chapter 0：魔工鑄器 Environment  工欲善其事，必先利其器。\n 教學目標  瞭解IDE是什麼。 學會安裝IDE。 學會基本IDE操作。  子章節   Dev-C++  Code::Blocks  Visual Studio  助教群的話 寫程式有各式各樣的方法，只要程式寫得出來都是好方法。\n阿!抄作業的方法在這邊不適用，被發現直接當掉，掰~ 就算你用記事本寫都沒問題。\n助教群，有一半是記事本(純文字編輯器)派的。\n"});index.add({'id':4,'href':'/docs/Ch1/01_history/','title':"01 History",'content':"C語言背景 C語言的由來 C語言最早由丹尼斯·里奇（Dennis Ritchie）為了在PDP-11電腦上運行的Unix系統所設計出來的程式語言，第一次發展在1969年到1973年之間。\nC源於BCPL語言，後者由馬丁·理察德（Martin Richards）於1967年左右設計實作。BCPL是一門\u0026quot;無類型\u0026quot;的程式語言：它僅能操作一種資料類型，即機器字（machine word）。1970年，肯·湯普遜為執行在PDP-7上的首個Unix系統設計了一個精簡版的BCPL，這個語言被稱為B語言，它也是無類型的。\nUnix最早運行在PDP-7上，是以組合語言寫成。在PDP-11出現後，丹尼斯·里奇與肯·湯普遜著手將Unix移植到PDP-11上，無類型的語言在PDP-11上愈發顯得合適。PDP-11提供了多種不同規格大小的基本物件：一位元組長的字元，兩位元組長的整型數以及四位元組長的浮點數。B語言無法處理這些不同規格大小的物件，也沒有提供單獨的操作符去操作它們。\nC語言最初嘗試通過向B語言中增加資料類型的想法來處理那些不同類型的資料。和大多數語言一樣，在C中，每個物件都有一個類型以及一個值；類型決定了可用於值的操作的含義，以及物件占用的儲存空間大小。\n1973年，Unix作業系統的核心正式用C語言改寫，這是C語言第一次應用在作業系統的核心編寫上。\n1975年C語言開始移植到其他機器上使用。史蒂芬·強生實作了一套「可移植編譯器」，這套編譯器修改起來相對容易，並且可以為不同的機器生成代碼。從那時起，C在大多數電腦上被使用，從最小的微型電腦到與CRAY-2超級電腦。C語言很規範，即使沒有一份正式的標準，你也可以寫出C程式，這些程式無須修改就可以執行在任何支援C語言和最小執行時環境的電腦上。\nC最初在小型機器上實作，並且繼承了一系列小語種程式語言的特點；與功能相比，C的設計者更傾向於簡單和優雅。此外，從一開始，C語言就是為系統級編程而設計，程式的執行效率至關重要，因此，C語言與真實機器能力的良好符合也就不足為奇。例如，C語言為典型硬體所直接支援的物件：字元，整數（也許有多種大小），以及浮點數（同樣可能有多種大小）提供了相應的基本資料類型。\nfrom wiki\n簡單的說\n C語言，於1969年至1973年間，由丹尼斯·里奇與肯·湯普遜， 以B語言為基礎，在貝爾實驗室設計、開發出來。\n "});index.add({'id':5,'href':'/docs/Ch1/02_language_diff/','title':"02 Language Diff",'content':"低中高階語言 程式語言就是人與電腦溝通的橋樑，\n就像世界上有很多語言，像是中文、英文、日文等等，\n程式語言也有很多種，像是C、C++、Java、Python，\n使用程式語言寫程式即可電腦溝通\nCPU只看得懂一種語言，叫做機器碼(Machine code)，\n所以需要跟CPU溝通的話就需要翻譯的存在， 將程式碼轉換成機器碼有三種方式，組譯、編譯、直譯\n 組譯(Assembling)  將組合語言轉換成機器語言 反過來將機器語言變成組合語言(Disassemble)  玩資安，寫外掛的重要技能   ex. 組合語言使用組譯器   直譯  透過直譯器(interpreter)對原始碼進行一邊讀解，一邊執行的動作 優點，在每個指令打完後就可以知道結果，較適合新手(but直譯跳到編譯難) 每次執行每次直譯 ex. python使用直譯器   編譯  將原始程式碼透過編譯器(Compiler)轉換成機器碼，再直接執行機器碼 優點；轉換速度快，可以一次找出不合文法的內容 原始程式 \u0026ndash;\u0026gt; 經由編譯器 \u0026ndash;\u0026gt; 變成目的檔 \u0026ndash;\u0026gt; 經由連結器 \u0026ndash;\u0026gt; 變成執行檔 SOURCE.C \u0026ndash;\u0026gt; COMPILER \u0026ndash;\u0026gt; SOURCE.OBJ \u0026ndash;\u0026gt; LINKER \u0026ndash;\u0026gt; SOURCE.EXE 編譯過一次後，以後只需要執行機器碼 ex. C語言使用編譯器    越接近CPU語言的叫低階語言，\n越接近人類語言的較高階語言，\n還有個剛好在中間的叫做中階語言。\n 低階語言  每一道指令對應一個 CPU 控制碼、程式碼超級多、重複性大 對硬體控制較好 程式效能較高 比較難懂 ex. 組合語言、機器碼   中階語言  原本C也算是高階語言，不過有些高階語言使用C編譯完的函式庫(Library) 因此有些人也稱C為高階語言 ex. C語言   高階語言  比較好懂，程式碼較少 較容易撰寫、除錯 對硬體控制能力較差、程式效能也較差 ex. python、Java    同一件事情，\n假設高階語言要寫十行程式碼，\n低階語言可能需要五百行，\n但，低階語言能直接做到很多高階語言不容易做到的事情。\n"});index.add({'id':6,'href':'/docs/Ch1/03_spec/','title':"03 Spec",'content':"特性  它的特性，總歸一句話，就是沒有特性！\n 由於很接近底層的組合語言，所以能做很多事情，透過指標，能夠直接控制、管理記憶體。\nC語言的設計理念是把工程師視為「成人」，「工程師」應該知道自己該做什麼，不像「小孩」需要特別的保護，他盡量給予工程師最大的彈性、自由，所以若是對C語言了解不夠深，就容易寫出有漏洞的程式，\u0026gt;成為駭客攻擊的目標。\n簡單的說\n C語言「想做什麼，就做什麼；做錯什麼，自己負責。」\n "});index.add({'id':7,'href':'/docs/Ch1/04_newbie/','title':"04 Newbie",'content':"起手式 學習每個程式語言的第一件事情，\n通常就是先做個簡單的程式來運行一下。\n來寫寫上大學之後的第一支程式吧!\n將指定的文字輸出到主控台上\n(寫到大四還在寫的Hello, world!\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello world!\\n\u0026#34;); return 0; } 語法 Syntax 就像英文有文法、中文也有文法一樣，每個程式語言也有它自己的語法，有嚴謹的，也有較寬鬆的，之後會一一介紹。\n標頭檔 Header 告訴編譯器(compiler)會用到哪些函式庫\n#include\u0026lt;stdio.h\u0026gt;告訴編譯器這個程式會用到 stdio.h這個表頭檔(Header file)中的函示定義\n stdio = standard input and output 標準輸入輸出  主程式 Main 程式開始的地方\nint main(){ ... } 寫了一大堆程式碼，總是要從一個地方開始執行\n由main開始\n主程式；Main function，程式進入點(Entry point)是main()這個函式\nint；執行完畢後回傳整數型態(將在五型殺氣 Basic I/O詳細介紹)\n( )；參數定義(將在三千世界 Function詳細介紹)\n{ }；程式內容(裡面就是這支程式要做的事情)\n程式主體 printf(\u0026#34;Hello world!\\n\u0026#34;); //印出 Hello world!  //\u0026#34;\\n\u0026#34;代表換行符號 return 0; //程式成功結束 printf ：印出後面參數內容(誇號內之內容，可用雙引號包含一段文字)，為C語言提供的標準輸出函式\nreturn ：回傳值，程式結束後會回傳一個數值，通常 0 表示正常結束(將在三千世界 Function詳細介紹)\n\\n ：換行符號，程式不會自動換行，如果沒加，下段文字會接在後面繼續寫\n註解 Comment  有點像是備忘錄，對自己寫的程式碼來點解釋  別人看不懂你的程式碼 看不懂自己的程式碼 作筆記 不算程式碼的內容    註解很重要，英文更重要，不懂英文，就看不懂註解，不懂註解就會處於一種尷尬的狀態。\n// 我是單行註解 ... /* 我是多行註解1 我是多行註解2 */ 縮排 Indent  #include \u0026lt;stdio.h\u0026gt;int main(){ printf(\u0026#34;Hello world!\\n\u0026#34;); return 0; } 比起上面來講，\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello world!\\n\u0026#34;); return 0; } 這個看起來會比較輕鬆愜意。\n編譯 Compile  還記得一開始講的程式編譯過程嘛  原始程式 \u0026ndash;\u0026gt; 經由編譯器 \u0026ndash;\u0026gt; 目的檔 \u0026ndash;\u0026gt; 經由連結器 \u0026ndash;\u0026gt; 執行檔 source.c \u0026ndash;\u0026gt; COMPILER \u0026ndash;\u0026gt; source.o \u0026ndash;\u0026gt; LINKER \u0026ndash;\u0026gt; source.exe   編譯、執行方式  gcc source.c -o run.exe ./run.exe   這時候就要說到 IDE 的方便了  F9 (Build and run) 只需要按一下    練習 1-1  練習1-1\n主控台 Console 一開始先學會使用純文字模式顯示，\n可能不像視窗化的程式(GUI)寫起來有成就感。\n只需要考慮程式邏輯，不用考慮排版，\n對初學者來說，更容易紮實的學習語言\n練習 1-2  練習1-2\n"});index.add({'id':8,'href':'/docs/Ch1/05_practice/','title':"05 Practice",'content':"練習 練習1-1 請將Hello, world!印出來。\n 補上可能會遇到的問題，通稱Bug   #include\u0026lt;xxxx.h\u0026gt;格式不對 左右括號要對稱，有開始就要有結束 ( ) { } 分號(；)沒打，告訴程式該陳述式(Statement)已結束 少了return 0；，要告訴程式已經正常結束 下面執行結果有錯誤訊息，很重要，他會跟你一輩子，跟到你心裏發毛。\n 練習 1-2 請將學號與姓名印出來\n"});index.add({'id':9,'href':'/docs/Ch1/Intro/','title':"Intro",'content':"Chapter 1：鑑往知來 C Intro  是故聖人見出以知入，觀往而知來，此其所以先知之理也。\n 教學目標  瞭解C語言的由來及背景 瞭解低中高階語言的差異 瞭解C語言與其他高階語言有何不同 用C語言撰寫第一支程式  子章節   C語言背景  低中高階語言  C語言特性  起手式  練習  助教群的話 如果不會C，也沒關係，我在上大學之前也不知道什麼是C\n 你只需要  英文，第一手資訊一定是英文，不要害怕英文 英文，很重要，所以又講了一次， 英文，超級重要\n 英文不好不用擔心\n這四年下來的鍛鍊英文白癡都可以變天才\n不過要花心思去練習\n  一顆新鮮的肝  花時間聽課 花時間練習 花時間研究課外的東西 花時間玩     上到現在，個人覺得資訊系最需要的能力  英文，還是他，別意外 自學能力，老師、助教在做的其實大部分是經驗傳承，師父領進門，修行在個人，學會了基本語法之後如何使用就看各位了 溝通能力，根據英國研究指出，工科學生的溝通能力都不太好，可是以後到哪都會用到，並且可以省去很多麻煩 興趣，找到自己的興趣最重要，寫程式、玩網路、玩資安等等，有興趣才做的久 技術，資訊系畢業不會寫程式\u0026hellip;   很認真不一定會為你帶來高分，多用點腦才是真的  很認真不代表我們要給你高分 努力和勞動是不同的，努力是有目的性地向前邁進；勞動只是重複做著同一件事情 大學了，該為自己的人生打算、負責了    "});index.add({'id':10,'href':'/docs/Ch10/01_introduction/','title':"01 Introduction",'content':"C++簡介 "});index.add({'id':11,'href':'/docs/Ch10/02_inputAndOutput/','title':"02 Input and Output",'content':"輸入與輸出 輸出(cout) 如同C語言中會有的 #include \u0026lt;stdio.h\u0026gt; …　return 0; ，等等必定會寫的內容一樣，以下是C++的基礎架構：\n範例10-1 #include \u0026lt;iostream\u0026gt;int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 以上為程式入門的Hello World!程式 從上述程式可以看到其實與C的架構相似，不同的只有#include \u0026lt;iostream\u0026gt;和std::cout \u0026lt;\u0026lt; ...的部分。\n在C++中，輸出字元會使用std::cout而非printf()，他能夠判斷型態內容自行輸出，而std::endl的效用為換行，也許一開始在printf()和std::cout的用法上會有一些不適應，不過多練習之後很快就能習慣的。所以請先練習以下題目：\n練習10-1 請使用std::cout輸出自己的生日、姓名及電話如以下範例\n1983/01/21 西嘉嘉 0987666666  如果一直打std::cout是不是會感到厭煩？如果會，那可以參考下面的寫法。\n範例10-2 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 在#include \u0026lt;iostream\u0026gt;後寫上using namespace std;，之後你寫上的cout和endl就不必再加上std::。\n為什麼會這樣呢？你可以想像在iostream中有許多個cout當你只有寫上cout時，編譯器沒有辦法判斷是哪一個cout，所以你必須寫std::cout，編譯器才能知道你要使用的為std這個namespace底下的cout，所以在最前面加上using namespace std;，編譯器就會默認你的cout為std下的cout。\n簡單來說，加上using namespace std;就只要寫cout而非std::cout，會方便許多。\n除了直接輸出字串，也可以直接輸出整數、變數和運算式的結果，請執行範例10-3。\n範例10-3 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ int ninetyNine = 99; cout \u0026lt;\u0026lt; \u0026#34;ninetyNine : \u0026#34; \u0026lt;\u0026lt; ninetyNine \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 : \u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ninetyNine + 1 : \u0026#34; \u0026lt;\u0026lt; ninetyNine+1 \u0026lt;\u0026lt; endl; return 0; } 輸入(cin) 講輸入之前，我們要先提變數型態，我們必須決定輸入型態，才能讓程式知道使用者輸入後的文字該以什麼方式解讀。\n   型態類型 保留字 佔用空間     字元 char 1 byte   寬字元 wchar_t 2 bytes   整數 short 2 bytes   整數 int 4 bytes   整數 long 4 bytes   浮點數 float 4 bytes   浮點數 double 8 bytes   浮點數 long double 12或16 bytes   布林 bool 1 byte    在練習時比較常用到的是char,int,float,double和bool這幾個型態，前四項於C語言時已經充分學習，布林將於下一小節進行說明。另外，在C語言時字串使用char陣列儲存，在C++使用string物件儲存，將於本章第四節進行說明，在此先講解C++的輸入。\n範例10-4 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ int num; cout \u0026lt;\u0026lt; \u0026#34;Please input \\\u0026#34;num\\\u0026#34;: \u0026#34;; cin \u0026gt;\u0026gt; num; cout \u0026lt;\u0026lt; \u0026#34;the \\\u0026#34;num\\\u0026#34;is \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; return 0; } 練習10-4 請參考範例10-4，讓使用者輸入小數並該小數印出。\n複習：if-else與switch-case 我們的程式經常會辨別使用者的輸入而產生不同的輸出，現在我們將練習兩種流程控制，if-else與switch-case。現在我們讓使用者輸入他的身高，若大於180則印出basketball，若大於165則印出baseball，若低於165則印出table tennis，請參考範例10-5：\n範例10-5 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ int height; cout \u0026lt;\u0026lt; \u0026#34;Please input your height:\u0026#34;; cin \u0026gt;\u0026gt; height; if(height \u0026gt; 180){ cout \u0026lt;\u0026lt; \u0026#34;baskeball\u0026#34; \u0026lt;\u0026lt; endl; }else if(height \u0026gt; 165){ cout \u0026lt;\u0026lt; \u0026#34;baseball\u0026#34; \u0026lt;\u0026lt; endl; }else{ cout \u0026lt;\u0026lt; \u0026#34;table tennis\u0026#34; \u0026lt;\u0026lt; endl; } } 練習10-5 請參考範例10-5畫出其程式流程\n除了if-else之外，若同時有多個分支需要判斷，我們可以使用switch-case，請參考範例10-6：\n範例10-6 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ char num; cout \u0026lt;\u0026lt; \u0026#34;Please input num:\u0026#34;; cin \u0026gt;\u0026gt; num; switch (num) { case \u0026#39;1\u0026#39;: cout \u0026lt;\u0026lt; \u0026#34;case 1\u0026#34; \u0026lt;\u0026lt; endl; break; case \u0026#39;2\u0026#39;: cout \u0026lt;\u0026lt; \u0026#34;case 2\u0026#34; \u0026lt;\u0026lt; endl; break; case \u0026#39;3\u0026#39;: cout \u0026lt;\u0026lt; \u0026#34;case 3\u0026#34;; break; default: cout \u0026lt;\u0026lt; \u0026#34;is not 1,2,3\u0026#34; break; } } 要注意的是，每個case後要放上break;，沒加會發生什麼事各位同學可以自行嘗試。而case '1'中1要加上單引號是因為表示為char型態，若要使其表示為整數型態則不需要加上單引號。\n練習10-6 請修改範例10-6，將num改為整數型態並使程式正確執行。\n總練習 請模擬一次性販賣機，讓使用者輸入投幣數量，並選擇a~d四種產品，若能夠購買則顯示購買成功，若錢不夠則顯示購買失敗，販賣機商品及價錢請參考下表。\n   商品代號 價錢     a 10   b 50   c 100   d 87    例子1\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：a 商品a購買成功  例子2\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：d 商品d購買失敗  "});index.add({'id':12,'href':'/docs/Ch10/03_boolean/','title':"03 Boolean",'content':"第六型態 布林 boolean 在C語言中，我們可能會宣告一個int作為條件判斷的變數，但我們從上一節的表格中可以看到兩者佔用空間是有所差距，int是4個bytes，而bool為1個byte，且程式碼管理上bool作為條件判斷的變數也會比其他型態更為清楚明瞭。\n在bool中提供兩個值，分別為true和false，兩者皆為c++的保留字，所以不能任意更改大小寫，請執行以下程式。\n範例10-7 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ bool flag; flag = false; if(flag){ cout \u0026lt;\u0026lt; \u0026#34;The flag is true!!!\u0026#34; \u0026lt;\u0026lt; endl; }else{ cout \u0026lt;\u0026lt; \u0026#34;The flag is false!!!\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;flag :\u0026#34; \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;flag :\u0026#34; \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; return 0; } 練習10-7 請使用前次範例並將flag的值設為false。\n在範例10-7可以發現，bool也是可以放進cout中印出的，印出結果為1或者0，若想印出true或false可以在flag前加上boolalpha\n我們常常會需要一個旗標(flag)來作流程控管，條件變數的暫存等等，各位同學若學到組合語言、計算機結構等課程應該會更有感覺。\n複習：while和for 有時候我們需要讓程式重複做某一件事情，我們可以藉由兩種方法做到，一是迴圈，二是遞迴，因為遞迴太過麻煩且不易使用所以在此不做複習。\n在C++中使用迴圈和C語言相同，使用while及for。\nwhile使用方式為，小括號內為繼續執行條件，大括號為執行動作。\n假設我們想讓使用者持續輸入數字，並使這些數字相加，當總和大於100時結束，請參考範例10-8：\n範例 10-8 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ int sum = 0,num; while(sum \u0026lt;= 100){ cout \u0026lt;\u0026lt; \u0026#34;please input a number to sum:\u0026#34;; cin \u0026gt;\u0026gt; num; sum = sum + num; cout \u0026lt;\u0026lt; \u0026#34;The \\\u0026#34;sum\\\u0026#34;is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } return 0; } 練習10-8 請參考範例10-8，改為讓使用者輸入5次數字後印出數字總和並結束程式。\n一般迴圈我們都會做三件事情，設定條件變數、設立終止條件、更改條件變數，以範例10-8為例子： 設定條件變數：int sum = 0; 設立繼續條件：sum \u0026lt;= 100 更改條件變數：sum = sum + num;\n我們更常會遇到的是如同練習10-8的狀況，條件變數是持續+1，所以我們就有了for的使用。\nfor的使用方式為，小括號內依序放入條件變數設定、繼續條件設立、條件變數更改，並用;隔開，大括號內為執行動作。\n範例10-9為顯示2的九九乘法表\n範例10-9 #include \u0026lt;iostream\u0026gt;using namespace std; int main(){ for(int i=1;i\u0026lt;10;i++){ cout \u0026lt;\u0026lt; \u0026#34;2*\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; 2*i \u0026lt;\u0026lt; endl; } return 0; } 練習10-9 請利用雙層迴圈(for)印出完整的九九乘法表，並排版。\n有別於舊版C語言，C++中可以在for裡面進行宣告的動作，使用for迴圈可以減少行數保持程式碼清潔。\n總練習 請更改上一節的總練習，並閱讀以下題目： 請模擬販賣機，讓使用者輸入投幣數量，並選擇a~d四種產品，若能夠購買則顯示購買成功並顯示退幣，若錢不夠則顯示購買失敗，如果輸入錯誤的代號則請使用者重新輸入，販賣機商品及價錢請參考下表。\n   商品代號 價錢     a 10   b 50   c 100   d 87    例子1\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：a 商品a購買成功，退幣40元 請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：d 商品d購買失敗 請投入金額：100 a:10 b:50 c:100 d:87 請輸入商品代號：d 商品d購買成功，退幣13元 請投入金額：100 a:10 b:50 c:100 d:87 請輸入商品代號：e 請輸入商品代號：e 請輸入商品代號：a 商品a購買成功，退幣90元  "});index.add({'id':13,'href':'/docs/Ch10/04_string/','title':"04 String",'content':"字串 string 接下來要介紹的是字串，在C語言中我們使用char陣列來表示字串，並使用string.h的函式對字串做處理，在C++中擁有string這個類別，意味著能夠比C語言更方便的使用字串。考慮到同學們還未學習物件導向，所以只先教導同學如何使用，若想學習物件導向請另找資源。\n請切記要#include\n請執行以下範例\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string str1(\u0026#34;I am string no.1\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;The string \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;\u0026#39;s size is \u0026#34; \u0026lt;\u0026lt; str1.size() \u0026lt;\u0026lt; endl; return 0; } 使用string時程式會自動開放空間存入，並不像char陣列一樣還要手動配置空間。str1.size()為C++的寫法，意義為請str1告訴我他的長度，在C語言要查詢string長度必須寫strlen(str1)，是使用strlen()查詢str1的長度，雖說結果相同，但寫法、內部結構和意義上卻是大相逕庭。\n當然，在實務上我們更常讓使用者輸入姓名等等資料，那就有別於上個範例的直接賦予值，在C++中讓使用者輸入我們使用cin加上\u0026gt;\u0026gt;，如以下範例所示。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string userName; cout \u0026lt;\u0026lt; \u0026#34;Please input your name:\u0026#34;; cin \u0026gt;\u0026gt; userName; cout \u0026lt;\u0026lt; \u0026#34;your name is \u0026#34; \u0026lt;\u0026lt; userName \u0026lt;\u0026lt; endl; if(userName==\u0026#34;Wang\u0026#34;){ cout \u0026lt;\u0026lt; \u0026#34;What a good name !!!\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 從這個範例中使用者若輸入Wang將會印出What a good name !!!，仔細看if的小括號內寫的是userName==\u0026quot;Wang\u0026quot;，這是因為string這個類別有定義屬於他的==，所以可以直接使用此種寫法，若是使用其他類別請先閱讀文件、查找資料或者做過嘗試後再使用。\nstring有很多功能可以使用，但本課程為教學資料結構，所以其餘功能請讀者自行查找資料嘗試。\n複習：副程式(function) 常常我們會持續地做同一事情，但這件事情由多行程式碼組成，這時候我們就需要用到副程式的概念，請參考下列兩種程式碼：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;math.h\u0026gt;using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;3,4 : \u0026#34; \u0026lt;\u0026lt; sqrt(3*3+4*4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5,12 : \u0026#34; \u0026lt;\u0026lt; sqrt(5*5+12*12) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8,15 : \u0026#34; \u0026lt;\u0026lt; sqrt(8*8+15*15) \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt;#include \u0026lt;math.h\u0026gt;using namespace std; float getHypotenuse(int a,int b){ return sqrt(a*a+b*b); } int main(){ cout \u0026lt;\u0026lt; \u0026#34;3,4 : \u0026#34; \u0026lt;\u0026lt; getHypotenuse(3,4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5,12 : \u0026#34; \u0026lt;\u0026lt; getHypotenuse(5,12) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8,15 : \u0026#34; \u0026lt;\u0026lt; getHypotenuse(8,15) \u0026lt;\u0026lt; endl; return 0; } 看似是第二段程式碼多了一些東西，但是你可以想像，假設今天你要做的這件事需要十行甚至更多程式碼，但是你突然發現了錯誤，那麼就需要砍掉這些程式碼重寫，那麼可能就會砍到其他程式碼。如果把它包成一個function，你會更方便做管理與除錯。\n副程式的架構為　回傳型態 副程式名稱(參數型態 參數名稱\u0026hellip;){要做的事}\n若沒有需要回傳的東西則寫void，副程式為一個大章節，請同學自己多做練習。\n補充：類別與物件 在此以最簡易的方式說明\n類別與物件的關係，可以想像成型態與變數，類別和型態都是用來概括一個類型，物件和變數才是真正會占用記憶體空間的資料。\nint num，int是型態，num是變數。string str1;，string是類別，str1是物件。 物件可以自己做事，但是變數只能被使用，更詳細的請參考物件導向設計。\n"});index.add({'id':14,'href':'/docs/Ch10/05_TernaryOperator/','title':"05 Ternary Operator",'content':"三元運算子 此章節需要修改\n在此稍微帶過三元運算子，效果可以當作if-else，只是可以一行完成，在if-else要做的事情不多時可以使用，或者是直接回傳二分法後的值。\n請參考以下範例：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt;using namespace std; int main(){ srand(time(NULL)); int point = rand()%15+3; cout \u0026lt;\u0026lt; point \u0026lt;\u0026lt; ((point \u0026gt; 10)? \u0026#34; is big\u0026#34;:\u0026#34; is small\u0026#34;); return 0; } 用法為 (條件)?正確做的事:錯誤做的事\n"});index.add({'id':15,'href':'/docs/Ch10/06_structAndObject/','title':"06 Struct and Object",'content':"結構與物件 C++的struct有別於C語言，可以在其中放入function與constructor，不過我個人並不建議使用，若已有物件導向觀念會較推薦使用class做編寫。\n以下先介紹最基礎的struct用法：\nstruct 結構名稱{ 型態1 變數名稱1; 型態2 變數名稱2; ... };  相較於C語言還要typedef，C++免於了這個麻煩，其餘要注意的是要記得加上分號。\n範例10-10 #include \u0026lt;iostream\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; }; int main(){ fraction a; a.son = 5; a.mom = 6; cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a.son \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; a.mom \u0026lt;\u0026lt; endl; return 0; } 以上為一個分數的結構，內部有分子和分母，在設定值時必須一個一個值設定，以下為使用function的範例：\n範例10-11 #include \u0026lt;iostream\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } }; int main(){ fraction a; a.son = 5; a.mom = 6; cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a.toDouble() \u0026lt;\u0026lt; endl; return 0; } 此時的struct會有一點類別的味道，因為a.toDouble()就是叫a告訴程式他toDouble後的結果，並非程式對他做運算。\n接下來要介紹constructor，中文為建構函式，這是當一個struct的物件(先暫時稱為物件)，被產生時會被呼叫的function，一般做為初始設定用，以下為範例：\n範例10-12 #include \u0026lt;iostream\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } fraction(int s,unsigned int m){ son = s; mom = (m!=0)?m:1; } }; int main(){ fraction a(5,6); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a.toDouble() \u0026lt;\u0026lt; endl; return 0; } constructor寫法為寫一個不含回傳值(void也不寫)的function，且function名稱為結構名稱，剩下的部分就如同寫副程式一樣，值得一提的是，我可以在這邊預防使用者將分母設為0，防止了toDouble()時會發生的錯誤。\n建構函式可以有多種，請記得寫不含參數的建構函式\n而宣告時就像呼叫function一樣，只是前方多了結構名稱，寫法很容易理解，但要熟悉還需要練習，下面要提的是destructor(解構函式)，他是destructor的相反，會在物件終結時執行，寫法就是constructor前面加上~，請參考以下範例\n範例10-13 #include \u0026lt;iostream\u0026gt;#include \u0026lt;stdlib.h\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } fraction(int s,unsigned int m){ son = s; mom = (m!=0)?m:1; } ~fraction(){ cout \u0026lt;\u0026lt; \u0026#34;the fraction dead.\u0026#34;; } }; int main(){ fraction a(5,6); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a.toDouble() \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 在未來如果在結構中用到動態記憶體配置，請記得在解構的時候將其free掉。\nstruct 與 class 相當相像，但請千萬不要搞混\n複習：陣列(Array) 陣列是一種資料結構，一般搭配迴圈使用，舉個最簡單的例子，我要印出座號1~10號的成績：\n範例10-14 #include \u0026lt;iostream\u0026gt;#include \u0026lt;stdlib.h\u0026gt;using namespace std; int main(){ int grade[10] = {12,54,75,24,8,97,45,32,58,60}; for(int i=0;i\u0026lt;10;i++){ cout \u0026lt;\u0026lt; \u0026#34;座號\u0026#34; \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt; \u0026#34;的成績: \u0026#34; \u0026lt;\u0026lt; grade[i] \u0026lt;\u0026lt; endl; } return 0; } 陣列的第一個位子為0。\n陣列很重要，陣列很重要，陣列很重要\nC++中struct陣列的其中一種寫法，另一種寫法將於下一節介紹，請參考以下範例：\n範例10-15 #include \u0026lt;iostream\u0026gt;#include \u0026lt;stdlib.h\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } fraction(){} fraction(int s,unsigned int m){ son = s; mom = (m!=0)?m:1; } ~fraction(){ } }; int main(){ fraction a[5]; for(int i=0;i\u0026lt;5;i++){ a[i] = {5+i,6+i}; cout \u0026lt;\u0026lt; \u0026#34;a[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]: \u0026#34; \u0026lt;\u0026lt; a[i].toDouble() \u0026lt;\u0026lt; endl; } return 0; } 總練習 請更改第三節的總練習，並閱讀以下題目： 請模擬販賣機，讓使用者輸入投幣數量，並選擇a~d四種產品，若能夠購買則顯示購買成功該樣商品名稱並顯示退幣，若錢不夠則顯示購買失敗，如果輸入錯誤的代號則請使用者重新輸入，販賣機商品及價錢請參考下表。\n   商品代號 商品名稱 價錢     a Atom 10   b World 50   c God 100   d human 87    請定義一個結構含有 編號、商品名稱、商品價格，使用陣列存取此結構物件。使用至少一個副程式(function)。\n例子1\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：a Atom購買成功，退幣40元 請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：d human購買失敗 請投入金額：100 a:10 b:50 c:100 d:87 請輸入商品代號：d human購買成功，退幣13元 請投入金額：100 a:10 b:50 c:100 d:87 請輸入商品代號：e 請輸入商品代號：e 請輸入商品代號：a Atom購買成功，退幣90元  "});index.add({'id':16,'href':'/docs/Ch10/07_memoryControl/','title':"07 Memory Control",'content':"記憶體操作 本章節將重點在使用struct*進行struct陣列的實作。\n在這之前我們先對指標(pointer)進行複習，也可參考本書第七章(鬼門遁甲 Pointer)。\n複習：指標(Pointer)  指標是一把鑰匙，這把鑰匙可以去打開一個置物櫃，而那個置物櫃裡可能會是資料或者另一把鑰匙。\n 指標可以視為一種資料型態，該資料型態儲存的資料唯一位址。\n使用符號*可以將儲存位址的值取出，使用符號\u0026amp;可以將本地位址取出。請參考範例10-16\n範例10-16 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ int* pointer; int value=1; pointer = \u0026amp;value; cout \u0026lt;\u0026lt; \u0026#34; value:\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;, \u0026amp;value:\u0026#34; \u0026lt;\u0026lt; \u0026amp;value \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;* pointer:\u0026#34; \u0026lt;\u0026lt; * pointer \u0026lt;\u0026lt; \u0026#34;,pointer:\u0026#34; \u0026lt;\u0026lt; pointer \u0026lt;\u0026lt; \u0026#34; ,\u0026amp;pointer:\u0026#34; \u0026lt;\u0026lt; \u0026amp;pointer \u0026lt;\u0026lt; endl; return 0; } 從上述範例可以看到，第七行我們將pointer的值設定為value的位址，以此練習了*及\u0026amp;的應用。\n陣列也是指標的應用之一，請參考範例10-17\n範例10-17 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ int* ptr; int value[3]={1,2,3}; ptr = value; cout \u0026lt;\u0026lt; \u0026#34;value[0]:\u0026#34; \u0026lt;\u0026lt; value[0] \u0026lt;\u0026lt; \u0026#34;, \u0026amp;value[0]:\u0026#34; \u0026lt;\u0026lt; \u0026amp;value[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;value[1]:\u0026#34; \u0026lt;\u0026lt; value[1] \u0026lt;\u0026lt; \u0026#34;, \u0026amp;value[1]:\u0026#34; \u0026lt;\u0026lt; \u0026amp;value[1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;value[2]:\u0026#34; \u0026lt;\u0026lt; value[2] \u0026lt;\u0026lt; \u0026#34;, \u0026amp;value[2]:\u0026#34; \u0026lt;\u0026lt; \u0026amp;value[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;value:\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;, \u0026amp;value:\u0026#34; \u0026lt;\u0026lt; \u0026amp;value \u0026lt;\u0026lt; \u0026#34;,* value:\u0026#34; \u0026lt;\u0026lt; * value \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;* ptr:\u0026#34; \u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; \u0026#34;, \u0026amp;ptr:\u0026#34; \u0026lt;\u0026lt; \u0026amp;ptr \u0026lt;\u0026lt; \u0026#34; ,* ptr:\u0026#34; \u0026lt;\u0026lt; * ptr \u0026lt;\u0026lt; endl; return 0; } 請參考圖片配合範例10-17\n 練習10-17 請參考圖片用另一種方式將陣列值印出，例:cout \u0026lt;\u0026lt; \u0026quot;*(value+1):\u0026quot; \u0026lt;\u0026lt; *(value+1) \u0026lt;\u0026lt; endl;\n另外，關於函式(function)中的參數，我們也可以放上指標，呼叫時就會傳位址給函式，這時我們在函式中改動值會影響到該參數，請比較範例10-18兩個程式。\n範例10-18 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; void valuePlusplus(int value){ value++; cout \u0026lt;\u0026lt; \u0026#34;in function value:\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } int main(){ int value = 0; valuePlusplus(value); cout \u0026lt;\u0026lt; \u0026#34;in main value:\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; void valuePlusplus(int * value){ (* value)++; cout \u0026lt;\u0026lt; \u0026#34;in function value:\u0026#34; \u0026lt;\u0026lt; * value \u0026lt;\u0026lt; endl; } int main(){ int value = 0; valuePlusplus(\u0026amp;value); cout \u0026lt;\u0026lt; \u0026#34;in main value:\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; return 0; } 請參考圖片： struct-array by pointer 範例10-19 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } fraction(){} fraction(int s,unsigned int m){ son = s; mom = (m!=0)?m:1; } ~fraction(){ cout \u0026lt;\u0026lt; toDouble() \u0026lt;\u0026lt; \u0026#34; deleted\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ fraction* fra[3]; for(int i=0;i\u0026lt;3;i++){ fra[i] = new fraction(-i,i+1); cout \u0026lt;\u0026lt; \u0026#34;fra[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]:\u0026#34; \u0026lt;\u0026lt; fra[i]-\u0026gt;toDouble() \u0026lt;\u0026lt; endl; } for(int i=0;i\u0026lt;3;i++){ delete(fra[i]); } return 0; } 以上作法為我們宣告了一個指標陣列，然後用new把物件放進陣列中，此種寫法要記得寫delete。\n範例10-20 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; struct fraction{ int son; unsigned int mom; double toDouble(){ double dnum = son; return dnum/mom; } fraction(){} fraction(int s,unsigned int m){ son = s; mom = (m!=0)?m:1; } ~fraction(){ cout \u0026lt;\u0026lt; toDouble() \u0026lt;\u0026lt; \u0026#34; deleted\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ fraction** fra = new fraction* [3]; for(int i=0;i\u0026lt;3;i++){ fra[i] = new fraction(-i,i+1); cout \u0026lt;\u0026lt; \u0026#34;fra[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]:\u0026#34; \u0026lt;\u0026lt; fra[i]-\u0026gt;toDouble() \u0026lt;\u0026lt; endl; } for(int i=0;i\u0026lt;3;i++){ delete(fra[i]); } delete(fra); return 0; } 10-20的作法為宣告一個雙指標的變數，然後用分別new指標陣列及物件把物件放進陣列中，此種寫法要記得將雙指標的變數也delete掉。\n10-20的作法會較佳，如果有新的陣列要建立可以直接使用該變數，而不用額外宣告一個指標陣列。\n練習 請定義學生資料，含有座號與姓名，並讓使用者輸入學生資料及印出所有學生資料。\n"});index.add({'id':17,'href':'/docs/Ch10/Intro/','title':"Intro",'content':"Chapter 10 天元突破 C++ Intro 本章節將簡易用C++複習基本程式邏輯，並教導C和C++的不同之處，以便接下來資料結構相關課程的銜接，因為並非是物件導向課程，故本章節並不會注重教導物件導向的觀念。\n"});index.add({'id':18,'href':'/docs/Ch11/01_Intro/','title':"01 Intro",'content':"Chapter 11：人形蜈蚣 Linked List 中文：鏈結串列、連結串列\n1.Introduction 簡介 Linked List 是資料結構的其中一種，利用節點與指標來將資料串起來，可以充分利用記憶體空間。 在 C/C++ 當中，我們將以 Linked List 來實作許多資料結構，如 Stack、Queue。\n通常，我們使用陣列來儲存相關的資料。但是陣列有其缺點：\n 宣告時就必須給予陣列大小 無法伸縮 必須是連續的記憶體空間  例如，有一個學生管理系統，我們需要宣告很多學生的變數，可能會這樣做：\nstruct Student { int stuID; }Student; Student student[10]; 可是，每一年的學生數量都不同，我們也無法預測未來的學生數量。 如果我們宣告的陣列太小，之後就會不夠用；若宣告的陣列太大，又浪費記憶體空間。\n這時，Linked List 就出場了。\n2.Concept 概念 有一個 節點（Node） 結構，裡面除了資料外，還有一個 節點型態的指標。 每當我們需要一筆新資料時，向系統要一塊空間，然後將指標指過去。\n以下便是單向 Linked List：\n 插入時的運作方式：\n 刪除時的運作方式：\n "});index.add({'id':19,'href':'/docs/Ch11/01_Intro_forC/','title':"01 Intro for C",'content':"Chapter 11：人形蜈蚣 Linked List 中文：鏈結串列、連結串列\n1.Introduction 簡介 Linked List 是資料結構的其中一種，利用節點與指標來將資料串起來，可以充分利用記憶體空間。 在 C/C++ 當中，我們將以 Linked List 來實作許多資料結構，如 Stack、Queue。\n通常，我們使用陣列來儲存相關的資料。但是陣列有其缺點：\n 宣告時就必須給予陣列大小 無法伸縮 必須是連續的記憶體空間  例如，有一個學生管理系統，我們需要宣告很多學生的變數，可能會這樣做：\nstruct Student { int stuID; }Student; Student student[10]; 可是，每一年的學生數量都不同，我們也無法預測未來的學生數量。 如果我們宣告的陣列太小，之後就會不夠用；若宣告的陣列太大，又浪費記憶體空間。\n這時，Linked List 就出場了。\n2.Concept 概念 有一個 節點（Node） 結構，裡面除了資料外，還有一個 節點型態的指標。 每當我們需要一筆新資料時，向系統要一塊空間，然後將指標指過去。\n以下便是單向 Linked List：\n 插入時的運作方式：\n 刪除時的運作方式：\n "});index.add({'id':20,'href':'/docs/Ch11/02_Singly_Linked_List/','title':"02 Singly Linked List",'content':"單向鏈結串列 Singly Linked List 1.Implementation 實作方向 在 C/C++ 當中，我們可以用 Struct（結構）來實作 Linked List。 在 C++ 當中，Struct 可以寫進方法，這個特性也讓我們實作上比較簡單。 C 當中的 malloc()，在 C++ 中我們用 new 來代替。\nA. 定義節點 首先我們必須先定義每個 節點（Node） 到底長什麼樣子。\n如同以下的程式碼，我們定義一個 data 節點，裡面有 int 型態的資料以及 Data 型態的指標，以及get方法。\nstruct Data{ int number; Data *next; int getData() { return this-\u0026gt;number; } }; B. 定義必要的指標 接著我們需要至少兩個指標，用來實作 Linked List 的各種功能。\n這兩個指標一個是 head，另一個是 current。head 永遠指向第一個節點，而 current 則是作為各種功能的定位點。不過current可以實作在方法裡面，也可以宣告為全域。\nDATA *head = NULL; C. 生成節點的方式 我們要開始來生成節點了。假如今天有一筆新的資料被加入，我們應該怎麼做呢？\n寫一個生成 function，向系統要一塊記憶體空間，然後把指標回傳。 不過，在C++裡面，我們可以直接用struct的建構子來搞定。\nstruct Data{ int number; Data *next; Data(int number) { this-\u0026gt;number = number; this-\u0026gt;next = NULL; } int getData() { return this-\u0026gt;number; } }; D. 使用 Linked List 作插入 我們有能力生成節點之後，必須把節點塞進我們的 Linked List 裡面。\n插入時的運作方式：\n //把 node2 塞到 node1 後面。 void insert_node(Data node1, Data node2) { node2-\u0026gt;next = node1-\u0026gt;next; node1-\u0026gt;next = node2; } E. 使用 Linked List 作刪除 用 malloc 要來的記憶體空間會放在 heap 而不是 stack，所以不會隨著 function 結束釋放， 必須要用 free() 釋放掉，否則會造成 memory leak。\n但在 C++ 中利用 new 就不必這樣做，我們改成用 delete 將其刪除。\n刪除時的運作方式：\n //刪除 n 的下一個 node void remove_node(Data* n) { //宣告一指標指向 n 的下一個節點 \tData* temp = n-\u0026gt;next; //將 n 指向下下一個節點  n-\u0026gt;next = n-\u0026gt;next-\u0026gt;next; //釋放被刪除節點的記憶體空間  delete temp; } F. 印出所有資料 void printAll() { Data* temp = head; cout \u0026lt;\u0026lt; \u0026#34;Data :\u0026#34; \u0026lt;\u0026lt; endl; while(temp-\u0026gt;next != NULL) { cout \u0026lt;\u0026lt; temp-\u0026gt;getData() \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; ; temp = temp-\u0026gt;next; } cout \u0026lt;\u0026lt; temp-\u0026gt;getData() \u0026lt;\u0026lt; endl; } 2. Examples 範例 #include \u0026lt;iostream\u0026gt;#include \u0026lt;stdlib.h\u0026gt; using namespace std; struct Data{ int number; Data *next; Data(int number) { this-\u0026gt;number = number; this-\u0026gt;next = NULL; } int getData() { return this-\u0026gt;number; } }; Data *head = NULL; void printAll() { Data* temp = head; cout \u0026lt;\u0026lt; \u0026#34;Data :\u0026#34; \u0026lt;\u0026lt; endl; while(temp-\u0026gt;next != NULL) { cout \u0026lt;\u0026lt; temp-\u0026gt;getData() \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; ; temp = temp-\u0026gt;next; } cout \u0026lt;\u0026lt; temp-\u0026gt;getData() \u0026lt;\u0026lt; endl; } void createNewDataAtLast(int number) { Data* temp = head; if(head == NULL) { head = new Data(number); } else { while(temp-\u0026gt;next != NULL) { temp = temp-\u0026gt;next; } temp-\u0026gt;next = new Data(number); } } int main(int argc, char const *argv[]) { while(1) { int choice; cout \u0026lt;\u0026lt; \u0026#34;Choose the function you want :\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1. Add data\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2. Print All datas\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3. Exit\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; choice; switch(choice) { case 1: int data; cout \u0026lt;\u0026lt; \u0026#34;Input data:\u0026#34;; cin \u0026gt;\u0026gt; data; createNewDataAtLast(data); cout \u0026lt;\u0026lt; \u0026#34;Add data successfully!\u0026#34; \u0026lt;\u0026lt; endl; break; case 2: printAll(); break; case 3: exit(0); default: cout \u0026lt;\u0026lt; \u0026#34;Error!\u0026#34; \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; endl; } return 0; } 練習 11-1 請設計一個 Linked List 程式，需要有建構子以及get方法，節點結構為：\nstruct Data{ int number; string name; Data *next; }; function 必須寫在 struct 裡面。\n必須要有選單讓使用選擇功能，可以重複使用，每次需要清除畫面。\n可以用以下功能：\n 新增資料  在最後面新增一筆資料   刪除  輸入要刪除的位置，執行刪除   印出所有資料  回家練習 11-2 同上，但功能有：\n 新增資料  在最後面新增一筆資料   插入資料  將一筆資料插入於特定位置   刪除  輸入要刪除的位置，執行刪除   修改  輸入要修改的位置，以及新的 number 和 name   查詢  輸入位置，印出數值以及名字   排序資料（按照 number）  重新排序整個 List   反轉整個 List 印出所有資料  一筆一筆印出 number 和 name   刪除所有資料  "});index.add({'id':21,'href':'/docs/Ch11/02_Singly_Linked_List_forC/','title':"02 Singly Linked List for C",'content':"單向鏈結串列 Singly Linked List 1.Implementation 實作方向 在 C/C++ 當中，我們可以用 Struct（結構）搭配 malloc() 來實作 Linked List。\nA. 定義節點 首先我們必須先定義每個 節點（Node） 到底長什麼樣子。\n如同以下的程式碼，我們定義一個 data 節點，裡面有 int 型態的資料以及 Data 型態的指標。\ntypedef struct data{ int number; struct data *next; }Data; B. 定義必要的指標 接著我們需要至少兩個指標，用來實作 Linked List 的各種功能。\n這兩個指標一個是 head，另一個是 current。head 永遠指向第一個節點，而 current 則是作為各種功能的定位點。不過current可以實作在方法裡面，也可以宣告為全域。\nData *head = NULL; C. 生成節點的方式 我們要開始來生成節點了。假如今天有一筆新的資料被加入，我們應該怎麼做呢？\n寫一個生成 function，向系統要一塊記憶體空間，然後把指標回傳。\nData* createNewNode(int number) { Data* temp = (Data*) malloc(sizeof(Data)); temp-\u0026gt;number = number; temp-\u0026gt;next = NULL; return temp; } D. 使用 Linked List 作插入 我們有能力生成節點之後，必須把節點塞進我們的 Linked List 裡面。\n插入時的運作方式：\n //把 node2 塞到 node1 後面。 void insert_node(Data* node1, Data* node2) { node2-\u0026gt;next = node1-\u0026gt;next; node1-\u0026gt;next = node2; } E. 使用 Linked List 作刪除 用 malloc 要來的記憶體空間會放在 heap 而不是 stack，所以不會隨著 function 結束釋放， 必須要用 free() 釋放掉，否則會造成 memory leak。\n刪除時的運作方式：\n //刪除 n 的下一個 node void remove_node(Data* n) { //宣告一指標指向 n 的下一個節點 \tData* temp = n-\u0026gt;next; //將 n 指向下下一個節點  n-\u0026gt;next = n-\u0026gt;next-\u0026gt;next; //釋放被刪除節點的記憶體空間  free(temp); } F. 印出所有資料 void printDataAfterNode(Data* start) { printf(\u0026#34;Data : \\n\u0026#34;); while(start-\u0026gt;next != NULL) { printf(\u0026#34;%d-\u0026gt;\u0026#34;, temp-\u0026gt;number); start = start-\u0026gt;next; } printf(\u0026#34;%d \\n\u0026#34;, start-\u0026gt;number); } void printAll() { if(head == NULL) { printf(\u0026#34;No data!\\n\u0026#34;); } else { printDataAfterNode(head); } } 2. Examples 範例 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct data{ int number; struct data *next; }Data; Data* head = NULL; Data* createNewNode(int number) { Data* temp = (Data*) malloc(sizeof(Data)); temp-\u0026gt;number = number; temp-\u0026gt;next = NULL; return temp; } void createNewDataAtLast(int number) { Data* temp = head; if(head == NULL) { head = createNewNode(number); } else { while(temp-\u0026gt;next != NULL) { temp = temp-\u0026gt;next; } temp-\u0026gt;next = createNewNode(number); } } void printDataAfterNode(Data* start) { printf(\u0026#34;Data : \\n\u0026#34;); while(start-\u0026gt;next != NULL) { printf(\u0026#34;%d-\u0026gt;\u0026#34;, start-\u0026gt;number); start = start-\u0026gt;next; } printf(\u0026#34;%d \\n\u0026#34;, start-\u0026gt;number); } void printAll() { if(head == NULL) { printf(\u0026#34;No data!\\n\u0026#34;); } else { printDataAfterNode(head); } } int main(int argc, char const *argv[]) { while(1) { int choice, data; printf(\u0026#34;Choose the function you want :\\n\u0026#34;); printf(\u0026#34;1. Add data\\n\u0026#34;); printf(\u0026#34;2. Print All datas\\n\u0026#34;); printf(\u0026#34;3. Exit\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); switch(choice) { case 1: printf(\u0026#34;Input data:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;data); createNewDataAtLast(data); printf(\u0026#34;Add data successfully!\\n\u0026#34;); break; case 2: printAll(); break; case 3: exit(0); default: printf(\u0026#34;Error!\\n\u0026#34;); break; } printf(\u0026#34;\\n\u0026#34;); } return 0; } 練習 11-1 請設計一個 Linked List 程式，節點結構為：\nstruct data{ int number; char name[20]; struct data *next; }; 必須要有選單讓使用選擇功能，可以重複使用，每次需要清除畫面。\n可以用以下功能：\n 新增資料  在最後面新增一筆資料   刪除  輸入要刪除的位置，執行刪除   印出所有資料  回家練習 11-2 同上，但功能有：\n 新增資料  在最後面新增一筆資料   插入資料  將一筆資料插入於特定位置   刪除  輸入要刪除的位置，執行刪除   修改  輸入要修改的位置，以及新的 number 和 name   查詢  輸入位置，印出數值以及名字   排序資料（按照 number）  重新排序整個 List   反轉整個 List 印出所有資料  一筆一筆印出 number 和 name   刪除所有資料  "});index.add({'id':22,'href':'/docs/Ch11/03_Doubly_Linked_List/','title':"03 Doubly Linked List",'content':"雙向鏈結串列 Doubly Linked List 1. What is Doubly LL? 什麼是雙向？ 前面的 Linked List 有個小問題，假如我今天要找 current 指標所指向的節點，往前兩個節點的資料時，必須要從 head 重新尋找起，而且程式會複雜一些。\n要解決這個問題，我們只要在節點中增加一個指標是往前指的，就可以了。\n示意圖：\n2. Implementation 實作 加上一個指標就行了。\nstruct Data{ int number; Data *next; Data *prev; }; 至於其他的方法，就要多增加一些程式碼，像是新增、刪除。\n想一下，自己寫寫看吧！\n 練習 11-3 請設計一個 雙向 Linked List 程式，需要有建構子以及get方法，節點結構為：\nstruct Data{ int number; Data *next; Data *prev; }; 有選單，可以用以下功能：\n 新增資料  在最後面新增一筆資料。   刪除  輸入要刪除的位置，執行刪除。   印出所有資料  一筆一筆印出 number。   印出第n個節點以及前後節點的資料  第4個功能，例如輸入5，則印出4,5,6節點的資料。如果沒有，就印出錯誤。\n"});index.add({'id':23,'href':'/docs/Ch11/03_Doubly_Linked_List_forC/','title':"03 Doubly Linked List for C",'content':""});index.add({'id':24,'href':'/docs/Ch11/04_Circularly_Linked_List/','title':"04 Circularly Linked List",'content':"循環鏈結串列 Circularly Linked List 1. What is Cirularly LL? 什麼是循環？ 也就是原本的最後一個節點指向第一個節點。\n示意圖：\n2. Implementation 實作 非常簡單，新增節點時把 next 指標指向 head 就可以了！\n練習 11-4 請設計一個 循環 Linked List 程式，需要有建構子以及get方法，節點結構為：\nstruct Data{ int number; Data *next; }; 有選單，可以用以下功能：\n 新增資料  在最後面新增一筆資料   刪除  輸入要刪除的位置，執行刪除   印出所有資料 第3個功能，必須從最後一個資料開始印，而不是從head開始。\n例如 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5，必須印出 5, 1, 2, 3, 4。  回家練習 11-5 請設計一 C/C++ 程式實作 二維(Two-Dimensional) 排序鏈結串列。程式要求如下：\n 程式開始時為一空串(Null list)。 讓使用者選擇要產生幾個亂數，由程式自動亂數產生介於1~999之間的整數，將此亂數依尾數(個位數)分組串連。\n(如Fig.(1)產生的亂數為123，且串列中初始並沒有尾數為3的組別，則建立一個尾數為3的組別後，將此亂數123按適當位置(即依序)串連於此組別內) 清除螢幕資料後印出目前串列狀態。 不斷重複前兩個步驟，將不重複的亂數依分組由小到大排列後串接起來，直到結束程式。\n(範例Fig.(2)，意謂若之後產生的亂數順序為3、223、125時，則將3、223加入原有的組別3串列中，而125則創建一個新組別5後再存於此串列中)  註：\n 必須讓使用者選擇要產生幾個亂數，產生出來的亂數不可以重複。 使用者選擇的亂數數量加上目前串列的長度，若超過 999，則印出錯誤，要求重新輸入。 此題需用鏈結串列(Linked List) 設計，程式碼數量、美觀、效率\u0026hellip;等則列入加分考量。 若產生的某個亂數已存在於串列中，則告知使用者，這個亂數不會被新增。 此程式需循環執行，直到使用者結束此程式。  Fig.(1)\nFig.(2)\n"});index.add({'id':25,'href':'/docs/Ch11/04_Circularly_Linked_List_forC/','title':"04 Circularly Linked List for C",'content':""});index.add({'id':26,'href':'/docs/Ch12/01_queue_intro/','title':"01 Queue Intro",'content':"佇列 Queue    不知道各位有沒有排隊買東西的經驗呢？在沒有任何插隊、解壓縮及特權的狀況下，基本上就是先到先服務的，晚來的只好乖乖排隊等前面的離開。\n佇列跟排隊可說是一模一樣，皆具有「先進先出(First-In-First-Out)」的特性，而佇列的頭跟尾，分別就是排隊時的隊伍頭尾了。\n一般來說，佇列不存在長度限制，長度越長，所需的寫入跟讀取代價時間較高，不過佇列長度還是有可能取決於系統跟記憶體空間多寡。\n(圖待補)\n新增/刪除資料 佇列在新增資料上有一定的規定，必須從後端(rear)進行新增，不能從其他位置新增資料(push)進去。\n佇列在刪除資料的時候也有規定，必須從前端(front)進行刪除，不能從其他位置刪除資料(pop)。\n(圖待補)\n"});index.add({'id':27,'href':'/docs/Ch12/02_queue_implementation/','title':"02 Queue Implementation",'content':"實作佇列 一般而言，佇列的實作有兩種方法，用陣列(array)或鏈結串列(linked list)實作，通常這兩者實做出來沒有太大的差別，唯一要注意的是，用array實作的佇列會有長度上的限制。\n以Array實作 首先，我們先要定義一個佇列結構，在這邊我們現暫訂佇列只能儲存整數，且限制長度為 100，同時我們需要一個 length 來儲存 現在的長度 ，而我們這邊先假定所有資料都不會是 零 ：\nsturct Queue{ int data[100]; int length; }; 緊接著是建構子(放在struct裡面)：\nQueue(){ this-\u0026gt;length = 0; for(int i=0; i\u0026lt; 100; i++) { data[i] = 0; } }; 接著分別來實作新增、刪除功能，新增功能(push)必須從後端放進去：\nvoid push(int num) { bool success = false; if (this-\u0026gt;length \u0026gt;= 0 \u0026amp;\u0026amp; this-\u0026gt;length \u0026lt; 100) { this-\u0026gt;data[this-\u0026gt;length] = num; success = true; } if (success) { this-\u0026gt;length++; } return; }; 刪除也是類似的方法，只不過刪除只能從前端刪除，而且每次移除，都必須將第 n 個往前移動一個位置：\nvoid pop() { bool success = false; if (this-\u0026gt;length \u0026gt; 0) { for(int i=1; i\u0026lt;100; i++) { this-\u0026gt;data[i-1] = this-\u0026gt;data[i]; } this-\u0026gt;data[99] = 0; success = true; } if (success) { this-\u0026gt;length--; } return; }; 接著，通常佇列可以知道前端的資料與後端的資料，因此我們需要幾個函式來存取第一筆跟第 n 筆資料：\nint front(){ if (this-\u0026gt;length == 0) { return 0; } else { return this-\u0026gt;data[0]; } }; int rear(){ if (this-\u0026gt;length == 0) { return 0; } else { return this-\u0026gt;data[this-\u0026gt;length-1]; } }; 以及，我們有時候會需要了解到這個佇列現在的狀態，因此加上「目前長度」、「是否為空」和「是否滿了」的函式：\nint size() { return this-\u0026gt;length; }; bool isEmpty() { return this-\u0026gt;length == 0; }; bool isFull() { return this-\u0026gt;length == 100; }; 最後，集上面之大成，你就有完整的佇列結構了！使用的方法和之前的 Linked List 很像：\n// 宣告物件 Queue *queue = new Queue(); // 新增資料 queue-\u0026gt;push(10); // 刪除資料 queue-\u0026gt;pop(); // 取得前端資料 queue-\u0026gt;front(); // 取得後端資料 queue-\u0026gt;rear(); // 取得佇列長度 quere-\u0026gt;size(); // 檢查佇列是否為空 queue-\u0026gt;isEmpty(); // 檢查佇列是否滿了 queue-\u0026gt;isFull(); 以Linked List實作 (待補)\n"});index.add({'id':28,'href':'/docs/Ch12/03_stack_intro/','title':"03 Stack Intro",'content':"堆疊 Stack 品O、薯X先生，這幾個還算有名的洋芋片品牌，不知道各位有沒有吃過？他們的共通點都是有個長長的桶子，裡面有滿滿的洋芋片。\n這些洋芋片桶子跟堆疊非常地像，假設洋芋片在沒有破損、一次只拿一片的狀況下，我們第一次拿到的就會是最上面(top)的洋芋片，第二次拿就會到上面數來第二片，直到第 n 次拿才會拿到最底部的洋芋片。\n這個特性就是堆疊所謂的「先進後出(First-In-Last-Out)」，最早放進去的東西會最後才會被取出來，而最後放進去的東西則會是第一個拿出來的。\n(圖待補)\n新增刪除資料 堆疊在新增資料時必須從頂端放進去。 堆疊在移除資料時必須從頂端開始移除。\n"});index.add({'id':29,'href':'/docs/Ch12/04_stack_implementation/','title':"04 Stack Implementation",'content':"實作堆疊 一般而言，堆疊的實作和佇列一樣，可以用陣列(array)或鏈結串列(linked list)實作，通常這兩者實做出來沒有太大的差別，唯一要注意的是，用array實作的佇列會有長度上的限制。\n以Array實作 首先，我們先要定義一個堆疊結構，在這邊我們現暫訂堆疊只能儲存整數，且限制長度為 100，同時我們需要一個 length 來儲存 現在的長度 ，而我們這邊先假定所有資料都不會是 零 ：\nsturct Stack{ int data[100]; int length; }; 緊接著是建構子(放在struct裡面)：\nStack(){ this-\u0026gt;length = 0; for(int i=0; i\u0026lt; 100; i++) { data[i] = 0; } }; 接著分別來實作新增、刪除功能，新增功能(push)必須從頂端(top)放進去：\nvoid push(int num) { bool success = false; if (this-\u0026gt;length \u0026gt;= 0 \u0026amp;\u0026amp; this-\u0026gt;length \u0026lt; 100) { this-\u0026gt;data[this-\u0026gt;length] = num; success = true; } if (success) { this-\u0026gt;length++; } return; }; 刪除也是類似的方法，和佇列不一樣的是，刪除只能從頂端刪除：\nvoid pop() { bool success = false; if (this-\u0026gt;length \u0026gt; 0) { this-\u0026gt;data[this-\u0026gt;length-1] = 0; success = true; } if (success) { this-\u0026gt;length--; } return; }; 接著，通常堆疊可以知道頂端的資料，因此我們需要一個top函式來存取最頂端的資料：\nint top(){ if (this-\u0026gt;length == 0) { return 0; } else { return this-\u0026gt;data[this-\u0026gt;length-1]; } }; 以及，我們有時候會需要了解到這個堆疊現在的狀態，因此加上「目前長度」、「是否為空」和「是否滿了」的函式：\nint size() { return this-\u0026gt;length; }; bool isEmpty() { return this-\u0026gt;length == 0; }; bool isFull() { return this-\u0026gt;length == 100; }; 最後，集上面之大成，你就有完整的堆疊結構了！使用的方法和堆疊很像：\n// 宣告物件 Stack* stack = new Stack(); // 新增資料 stack-\u0026gt;push(10); // 刪除資料 stack-\u0026gt;pop(); // 取得頂端資料 stack-\u0026gt;top(); // 取得佇列長度 stack-\u0026gt;size(); // 檢查佇列是否為空 stack-\u0026gt;isEmpty(); // 檢查佇列是否滿了 stack-\u0026gt;isFull(); 以Linked List實作 (待補)\n"});index.add({'id':30,'href':'/docs/Ch12/05_practice/','title':"05 Practice",'content':"練習 Queue (待補)\nStack   請利用Stack撰寫一個走迷宮程式\n  請利用Stack撰寫一個中序運算式轉後序運算式的程式。\n  中序運算式: 1+2*3/4-5 後序運算式: 123*4/+5- "});index.add({'id':31,'href':'/docs/Ch12/Intro/','title':"Intro",'content':"Chapter 12：陰陽一氣 Queue \u0026amp; Stack  堆疊之行，先進後出；佇列之行，先到先贏！\n 教學目標  了解Queue原理 能夠以陣列及鏈結串列實作Queue 了解Stack原理 能夠以陣列及鏈結串列實作Stack  子章節   佇列簡介  實作Queue  堆疊簡介  實作Stack  "});index.add({'id':32,'href':'/docs/Ch13/Intro/','title':"Intro",'content':"Chapter 13：木葉旋風 Tree 中文：樹\n 別人的樹是由下往上長，我們由上往下長。\n 各項樹簡介 舉凡從企業內的組織架構、家族內的族譜關係再到電腦領域中的作業系統與資料庫管理系統都是樹狀結構的衍生運用。\n 完滿二元樹(Fully binary tree) 完整二元樹(Complete binary tree) 歪斜樹(skewed binary tree) 嚴格二元樹(strictly binary tree)  詳細請見正課講義。\n以linked list實作運算樹(Expression Trees) 這其實也就是一個二元樹，只是我們需要將運算式的內容依序塞入樹中 我們要如何建立一個以LL為實作基準的二元樹呢?\nnode 再節點上面我們可以看到其實只需要照著如 上圖去建立，有一個值value以及兩邊的pointer即可\n好，那接下來怎麼建立我們的運算樹呢? 其實我們需要有一些先建立的基本知識\n輸入 當我們再建立運算樹的時候會先將輸入轉為後序式 這我們這樣做的時候，就可以比較方便的建立運算樹\n如何將後序式建成tree 其實當我們要將後序式建成tree的時候我們可以利用一個stack來做，我們可以利用迴圈來幫助我們讀取輸入的字串，並依據下列順序來做\n 如果是運算元(1、2、3\u0026hellip;等)則push進stack 如果是運算子(+、-、*\u0026hellip;等)則pop出兩項value並利用該運算子所建立之node建立連結，之後再將該運算子節點push入stack。  經由上述的步驟即可將後序式建立成tree\n練習 好啦 既然演算法都告訴大家了，那也該開始實作拉~各位加油!!\n樹的走訪 當我們根據上面的方法把樹建立起來之後，那又該怎麼去走訪呢? 這個部份其實在正課的講義已經有了，所以這邊我們簡單舉一個例子 如圖: 各項走訪我們參考正課講義\n中序走訪的遞迴演算法  前序走訪的遞迴演算法  後序走訪的遞迴演算法  依據上述的虛擬碼其實就可以依序以三種方式走訪該tree。\n"});index.add({'id':33,'href':'/docs/Ch14/Intro/','title':"Intro",'content':"Chapter 14：木靈迷路 Graph 各種圖簡介 Kruskal Prime Dijkstra "});index.add({'id':34,'href':'/docs/Ch2/01_stdout/','title':"01 Stdout",'content':"標準輸出(stdout) 標準輸出，是C語言入門中一定會先學到的東西，它的意義是「將指定的字串輸出到主控台(Console)上」，一般而言我們的主控台就是我們的螢幕，在先前我們寫的第一支程式，就印出了\u0026quot;Hello world!\u0026ldquo;這串字。\n當然再寫一個程式，並不能只有輸出，我們還需要一些資料輸入及計算過程，少了其中一個，那麼你的程式就有點奇怪了。\n程式有好幾種分類方法，我們可以用有沒有輸入/計算/輸出來把程式分成2類：\n 一般程式：好手好腳，有輸入/計算/輸出。 通靈程式：缺少輸入/計算/輸出任何一樣。\n輸入及計算我們會在後面的章節提到，現在讓我們把焦點放在標準輸出上面。  輸出函式 在C語言裡，提供輸出功能的函式有幾個，分別是：\n printf() putc() puts() write() 通常我們常常會利用printf()的格式控制字串來處理輸出。  格式控制字串 printf()是一個非常特別的函式，其中可以帶入數個參數，其中第一個參數必定為被兩個 \u0026quot; 夾住的東西，我們稱呼他為「格式控制字串」。\n只要在這個格式控制字串裡面寫入對應的字元，就可以觸發特定的輸出效果。\n   格式控制字元 效果     \\a 輸出一個警告音   \\b 輸出一個後退(backspace)   \\n 輸出一個換行   \\r 輸出一個歸位   \\t 輸出一個tab    又或者，要輸出某些特殊符號例如：單引號(')、雙引號(\u0026quot;)、斜線(\\)，我們也需要用「\\」這個跳脫字元來協助。\n   格式控制字元 效果     \\ 輸出一個 \\   ' 輸出一個 '   \u0026quot; 輸出一個 \u0026quot;    練習 請試著輸出你的班級、學號、姓名！\nint main(){ printf(\u0026#34;班級：資訊一癸\\n\u0026#34;); printf(\u0026#34;學號：D9876543\\n\u0026#34;); printf(\u0026#34;姓名：釋泛立\\n\u0026#34;); } printf()的功能還有很多，我們將再接下來教完型態之後一併學習。\n"});index.add({'id':35,'href':'/docs/Ch2/02_type/','title':"02 Type",'content':"基礎五型 C語言之中，型態是所有資料儲存的基本，想要儲存資料，得先分清楚型態是什麼，也因此在輸出之後，緊接而來的就是「型態」。\n我們可以透過宣告某個型態的「變數」，來儲存該類型的「資料」，而C語言的型態共有五種，分別是int、float、double、char以及void，以下就分別介紹他們。\nint int，全文是integer，也就是我們中文所說的「整數」，舉凡0、1這類沒有特殊符號的數字，都可以用int來儲存。\n在C語言中，一個int變數就是占用 4 bytes 的記憶體空間，換言之，它所能保存的數值範圍只有 2147483647 ~ -2147483648。\nint a = 1; int b = -1; int c = 2147483647; int d = -2147483647;  INT 的儲存範圍定義在 limits.h 中，會根據系統及函式庫實作上而有所差別，基準值為 2147483647(or greater) ~ -2147483647(or less)git p\n 而輸出時，我們要使用一些方式來讓printf()認得這小祖宗是整數(int)：\nprintf(\u0026#34;%d\\n\u0026#34;, num); 然而，光一個整數就有許許多多不同的表達方式，例如：八進位、十六進位等等，因此簡單列了個表格說明：\n   格式控制字元 意義     %d 輸出有號整數   %o 輸出無號八進位整數   %x 輸出無號十六進位整數(小寫)   %X 輸出無號十六進位整數(大寫)    printf(\u0026#34;%d\\n\u0026#34;, 10); // 10 printf(\u0026#34;%o\\n\u0026#34;, 10); // 12 printf(\u0026#34;%x\\n\u0026#34;, 10); // a printf(\u0026#34;%X\\n\u0026#34;, 10); // A 因此一個整數就可以有四種輸出變化，不過要特別注意的是，轉換輸出成八進位及十六進位是沒有正負號的。\nfloat float，中文稱為「浮點數」，用比較耳熟能詳的單字就是「小數」，負責去儲存0.1、-1.2、0.0這種帶有小數點的數字。\n在C語言中，float是一個單精度浮點數，一個float變數就是占用 4 bytes 的記憶體空間，通常小數點後六位之後的問算都可能會有誤差。\nfloat a = 0.1; float b = -1.2; float c = 0.0; 那要輸出一個浮點數相對於整數就簡單多了，你只需要：\nprintf(\u0026#34;%f\\n\u0026#34;, num); 不過，如果你是指數愛好者，或許你會比較喜歡以科學記號方式來顯示：\nprintf(\u0026#34;%e\\n\u0026#34;, num); printf(\u0026#34;%E\\n\u0026#34;, num); printf(\u0026#34;%g\\n\u0026#34;, num); printf(\u0026#34;%G\\n\u0026#34;, num); %e 及 %E 的差別在於英文字母 E 的大小寫，而 %g 和 %G 則分別是取 %e 及 %E 和 %f 較短的那個。\ndouble double，中文稱為「倍精度浮點數」，簡單來說，double也是拿來儲存小數的型態，只不過可以存的比較精準。\n在C語言中，一個 double 變數就是占用 8 bytes 的記憶體空間，通常小數點後15位之後的問算都可能會有誤差。\ndouble a = 0.1; double b = -1.2; double c = 0.0; 要輸出一個double變數跟輸出float很類似，只要加個符號就好：\nprintf(\u0026#34;%lf\\n\u0026#34;, num); char char，全文是character，中文稱為「字元」，可以儲存ASCII表上所有的字元，其中就包括了所有的標點符號、英文字母及數字。\n在C語言中，一個char只占用了 1 byte 的記憶體空間，不過實際上使用的只有 7 bits，換言之，真正儲存範圍只有 -127 ~ 127。\n在定義字元的時候，我們可以用單引號(')將字母或標點符號夾住來表示該字元，或者是用對應的ASCII碼。\nchar ch = \u0026#39;A\u0026#39;; char ch2 = 65; 在廣義上，char屬於整數家族的一員，因此 char 跟 int 在數值不大的狀況下可以直接進行轉換。\n而要輸出一個字元，我們可以簡單的使用：\nprintf(\u0026#34;%c\u0026#34;, ch); 另外，值得一提的是，我們先前所提到的格式控制字元，全部都是char所可以儲存的。\nvoid void，中文稱為「空」、「虛無」，是整個C語言中最特別的型態，因為 void 變數不能儲存任何資料。\n基本上，當你定義了 void 變數的時候，就會得到一個錯誤。\n不過，void 在別的地方確有其意義，我們在未來的副函式及指標章節，會有額外的介紹。\n練習 請試著宣告變數，儲存以下資料：\n 1 -10 48 99.5 99.555555555 \u0026lsquo;0\u0026rsquo; \u0026lsquo;\\a\u0026rsquo;  "});index.add({'id':36,'href':'/docs/Ch2/03_changable/','title':"03 Changable",'content':"伸縮自如的型態 有時候，我們總是會有特殊的需求，例如：大一點的範圍、不要負號等等，因此，C語言也提供了一些彈性的變化，讓我們來瞧一瞧這些彈性。\nshort 在上一章節，我們有提到 int 佔用了 4 bytes，不過假如要儲存的數字沒有那麼大，用 int 儲存，真的可謂殺雞用牛刀。\nshort，中文稱為「短的」，是一個將型態佔用空間砍半的修飾詞，只能用在 int 上。\nshort a = 1; short b = 32767; short c = -32767; 或者，你也可以這樣寫：\nshort int a = 1; short int b = 32767; short int c = -32767; 最後的問題是，我們要怎麼把這個佔用空間砍半的東西輸出呢？方法很簡單，只需要加點手腳：\nprintf(\u0026#34;%hd\u0026#34;, num);  如果不在 short 後面指定型態，預設使用 int。\n long 有辦法縮小就有辦法拉長！如果 4 bytes 不夠你用，那你可以試試看 8 bytes 的 long long int。\nlong，中文稱為「長的」，是一個將型態佔用空間變成翻倍的修飾詞，可以用在 int、double、char 上。\nlong a = 2147483648; 聰明的你或許會猜到，那它是否和short一樣，可以在後面加上 int 呢？\n答案是「可以」，只是有些小地方需要你特別注意！\n在 64 位元的系統上，一個 long 會各自表述，最大的差別在 Windows 及所有 Unix 及類 Unix 系統上，前者一樣是 4 bytes，後者則是 8 bytes！\n因此，在 Windows 上，如果你輸入的是這串：\nlong a = 9876543210; long int b = 9876543210; 那麼你可能會收到編譯器的警告，因為它超過 4 bytes 所能儲存的範圍，也就是發生了 溢位！\n你必須改成這樣寫才行：\nlong long int a = 9876543210; 而在 Unix 及所有類 Unix 的系統上，不用擔心這個問題，你用哪個都一樣。\n既然前面都這麼麻煩了，那輸出肯定也是個苦差事！\n當你今天使用 long 或 long int 宣告時，你必須這樣寫：\nprintf(\u0026#34;%ld\u0026#34;, num); 不過，如果你是寫 long long int，那你就得要加上一個 l：\nprintf(\u0026#34;%lld\u0026#34;, num);  如果不在 long 後面指定型態，預設使用 int。\n 還有，浮點數也可以加上 long 來修飾，變成更長的浮點數！\nlong double e = 3.1415926; printf(\u0026#34;%Lf\u0026#34;, e); 至於他總共佔用幾 bytes？當然是 16 bytes 囉！\n long double 在 C99 才能正常使用。\n unsigned 有時候我們不需要正負號，當我們可以另外處理正負號的時候，我們便可以使用 unsigned 來取消正負號。\nunsigned，中文稱為「無號的」，是一個將有號型態變成無號型態的修飾詞，通常會用來使該型態能儲存的值變成兩倍，只能用在 int 及 char。\nunsigned int a = 4294967295; unsigned char b = 255; 如果你在 unsigned 中使用了負數，那麼你的數字會發生溢位，變回正數，舉例來說：\nunsigned int a = -1; unsigned int b = 255; 上面兩者值是一模一樣的！\n當你需要輸出的話，則是要更換控制字元：\nprintf(\u0026#34;%u\u0026#34;, num);  如果不在 unsigned 後面指定型態，預設使用 int。\n 並且，unsigned 還可以跟 short 及 long 混搭 (僅限int)，例如：\nunsigned short a = 1; unsigned short int a = 1; unsigned long a = 1; unsigned long int a = 1; unsigned long long int a = 1; 控制字元 我們剛剛都在談型態「宣告時」的彈性，現在我們要來聊聊「輸出時」的彈性。\nprintf()還可以做到例如：「限制輸出字數」、「限制小數點後幾位」、「強制顯示正負號」、「對齊」等等，下面做了一張表作簡單的統整：\n   修飾子 效果 範例     - 靠左對齊 %-d   + 顯示正負號 %+d   (空白) 當正數顯示空白，負數顯示負號 % d   (數字) 最小固定顯示幾個字 %6d   0 在最小固定欄位的字元前加上0，不能和 - 一起使用。 %06d   .(數字) 小數點之後要顯示幾個字 %.3f    最後，如果你恰巧需要輸出一個 % 符號，你會需要這樣寫：\nprintf(\u0026#34;%%\u0026#34;); 練習 請試著使用上面所學，宣告適當的變數，使輸出畫面和下面一模一樣：\na = -1; b = 0; c = 1; d = 32767; e = -32767; f = 32768; g = 65535; h = 2147483647; i = -2147483647; j = 4294967295; k = -4294967295; l = 9223372036854775807; m = -9223372036854775807; n = 18446744073709551615; o = 3.141592; p = 3.141592653589793; "});index.add({'id':37,'href':'/docs/Ch2/04_stdin/','title':"04 Stdin",'content':"標準輸入(stdin) 如果有了一個裝水的容器，卻不能填滿它，那不是很可惜嗎？\n前幾章節我們提到了，一個程式需要有輸入/計算/輸出，我們現在已經能夠順利地宣告變數便將其印出，那緊接著就是把東西塞進變數裡面了。 在輸入的時候，你除了必須了解你輸入的東西是什麼型態，例如：10 是整數、3.14 是浮點數及 A 是字元，更要注意的是要用「多大的空間」去儲存。\n輸入函式 和輸出一樣，C語言提供了許多輸入的函式供大家使用，包括：\n scanf() getc() gets() read() 其中和 printf() 互相呼應的便是 scanf() 了，下面就來介紹這個輸入函式。  scanf scanf() 的用法和 printf() 有點類似，都是透過格式控制字串來決定要怎麼輸入，舉個例子：\nint num; double fnum; char ch; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); scanf(\u0026#34;%lf\u0026#34;, \u0026amp;fnum); scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); 格式控制字串中帶有 %d ，代表著我要輸入一個整數，並將它存到 num 中。\n接著，讓我們再次複習一下幾個常用的格式控制字元代表的型態吧：\n   格式控制字元 型態     %d 整數(int)   %lld 長整數(long long int)   %u 無號整數(unsigned int)   %f 單精度浮點數(float)   %lf 倍經度浮點數(double)   %Lf 長倍經度浮點數(long double)   %c 字元(char)    各位務必注意，在 scanf() 中，不可以使用以「\\」開頭的任何格式控制字元，例如：換行「\\n」、Tab「\\t」都不可以出現在 scanf() 中。\n取址運算子 「\u0026amp;」是一個相當特殊的運算子，它的功能是「取得一個變數的地址」。\n在 scanf() 中，除了要提供要輸入的型態，同時也要指定他要存到哪裡去，但是只指定變數是不夠的，scanf()需要明確知道要寫到「哪裡去」， 因此我們需要加上取址運算子「\u0026amp;」，讓 scanf() 直接將輸入的東西寫到指定位置上。\n關於記憶體控制及相關概念會在之後再詳細講解，現在大家只要知道使用 scanf() 時要加上 \u0026amp; 即可。\n練習 請宣告幾個變數依序儲存以下輸入的資料，並以相同方式輸出到螢幕上。\nA 3.14159 9223372036854775807 "});index.add({'id':38,'href':'/docs/Ch2/05_practice/','title':"05 Practice",'content':"練習 是非題  任何程式只要有輸入及輸出就好。 char 和 int 都是儲存的都是整數。 float 在計算時完全不會有任何誤差。 unsigned 儲存的是非正整數。 不可以在 scanf() 中使用 \\a。  選擇題  請問一個 int 佔用幾個 byte 的記憶體空間？\n(A) 4 (B) 8 (C) 16 (D) 32 請問一個 long int 在 Unix 系統上佔用幾個 byte 的記憶體空間？\n(A) 4 (B) 8 (C) 16 (D) 32 請問 %c 對應的型態是什麼？\n(A) int (B) float (C) double (D) char 請問 %lf 對應的型態是什麼？\n(A) int (B) float (C) double (D) char 請問 %lu 對應的型態是什麼？\n(A) unsigned int (B) unsigned long (C) unsigned double (D) unsigned char  問答題  請問 100 以 %08d 輸出的結果為何？ 請問 55.32876 以 %4.2d 輸出的結果為何？ 請問 65 以 %c 輸出的結果為何？ 請問 \u0026lsquo;A\u0026rsquo; 以 %d 輸出的結果為何？ 請問 9876543210 以 %u 輸出的結果為何？ 請問 scanf(\u0026quot;%d\u0026quot;, \u0026amp;num) 時，輸入 100 ，num 值為何？ 請問 scanf(\u0026quot;%f\u0026quot;, \u0026amp;num) 時，輸入 3.1415926 ，num 值為何？ 請問 scanf(\u0026quot;%d\u0026quot;, \u0026amp;num) 時，輸入 100.125 ，num 值為何？ 請問 scanf(\u0026quot;%d\u0026quot;, \u0026amp;num) 時，輸入 9876543210 ，num 值為何？ 請問 scanf(\u0026quot;%c\\n\u0026quot;, \u0026amp;num) 時，輸入 6 ，num 值為何？  "});index.add({'id':39,'href':'/docs/Ch2/Intro/','title':"Intro",'content':"Chapter 2：五型殺氣 Basic I/O  基礎五型，奠定C語言基礎架構。\n 教學目標  學會一般程式基礎架構 瞭解C語言的輸入及輸出方式 瞭解C語言的五種型態及變化型態。 能用C語言撰寫出帶有輸入輸出及各種型態的程式。  子章節   標準輸出  基本五型  伸縮自如的型態  標準輸入  練習  "});index.add({'id':40,'href':'/docs/Ch3/01_arithmetic/','title':"01 Arithmetic",'content':"算數運算 不同於上述幾個章節所寫的內容，在這章節我們將會開始講述一些C的基本運算。 但是本章節僅會介紹一些基礎比較常使用到的運算子，當然還有更多東西可以挖掘，這部分就可能得讓大家在未來需要時可以自己去搜尋網路上的資料，將會更加齊全及完整。\n算數運算式 一個運算式基礎會由運算元(Operands)、運算子(Operators)和間隔符號(Delimiters)等三者所組成。舉一案例來說：\nA+B/(A-B) 其中運算元(Operands)就像是上面這個案例的A和B，而運算子(Operators)則是算式中的+、/及-，理所當然的剩下來的括號自然就是間隔符號(Delimiters)了。\n算數運算子 C 語言的算術運算子比較常見的例如:加、減、乘、除、取餘數\u0026hellip;等，皆需兩個運算元構成運算式，而這類型的運算子就稱為「二元運算子」，如下列所示：\n   運算子 意義 舉例     + 加 A+B   - 減 A-B   * 乘 A*B   / 除 A/B   % 取餘數 A%B    遞增及遞減運算子 在 C 語言裡面還有一種比較常使用到的用法是「單元運算子」，僅需要一個運算元就是運算式了。聽起來有些繞口，可以直接看以下表格：\n   運算子 意義 舉例     ++ 運算前遞增 ++A   ++ 運算後遞增 A++   \u0026ndash; 運算前遞減 \u0026ndash;B   \u0026ndash; 運算後遞增 B\u0026ndash;    課堂演練 直接從程式面去看的話\n#include \u0026lt;stdio.h\u0026gt;int main(){ int temp1=13; int temp2=13; int temp3=13; int temp4=13; printf(\u0026#34;算數運算子\\n\u0026#34;); printf(\u0026#34;13 + 8 = %d\\n\u0026#34;, 13+8); printf(\u0026#34;13 - 8 = %d\\n\u0026#34;, 13-8); printf(\u0026#34;13 * 8 = %d\\n\u0026#34;, 13*8); printf(\u0026#34;13 / 8 = %d\\n\u0026#34;, 13/8); printf(\u0026#34;13 %% 8 = %d\\n\\n\u0026#34;, 13%8); printf(\u0026#34;遞增及遞減運算子\\n\u0026#34;); printf(\u0026#34;++temp1 + 8 = %d\\n\u0026#34;, ++temp1+8); printf(\u0026#34;temp2++ + 8 = %d\\n\u0026#34;, temp2+++8); printf(\u0026#34;--temp3 + 8 = %d\\n\u0026#34;, --temp3+8); printf(\u0026#34;temp4-- + 8 = %d\\n\\n\u0026#34;, temp4--+8); printf(\u0026#34;temp1:%d\\n\u0026#34;,temp1); printf(\u0026#34;temp2:%d\\n\u0026#34;,temp2); printf(\u0026#34;temp3:%d\\n\u0026#34;,temp3); printf(\u0026#34;temp4:%d\\n\u0026#34;,temp4); return 0; } 看完上述程式執行之後對於算數、遞增及遞減運算子應該都有基本認識了吧？在下個章節我們將會介紹其他的運算子。\n練習 讓程式輸入一個大寫英文字母輸出該字母的小寫 如圖所示:\n提示:ASCII內\u0026rsquo;A'代表數字為65，\u0026lsquo;a'則為97。\n"});index.add({'id':41,'href':'/docs/Ch3/02_bitComputing/','title':"02 Bit Computing",'content':"位元運算  Life is binary zeros and ones.\n 在這章節我們將會介紹C 語言的位元運算。 相信大家對於位元應該都已經有了基本的認識，在這種情況下再來看位元運算會比較好理解。\n位元運算子 在電腦中資料的儲存都是利用0/1的編碼進行儲存，像是一個平常普通的十進位數字 10 跟 7，在電腦裡的儲存假設是4個位元則是:\n10 -\u0026gt; 1010 7 -\u0026gt; 0111 而在 C 語言裡面有許多的運算子是專門針對位元進行運算的，如下表:\n 運算子 意義 舉例   \u0026amp; 且(and) A\u0026B   | 或(or) A|B   ^ 互斥或(xor) A^B   \u0026lt;\u0026lt; 向左位移 A\u0026lt;\u0026lt;B   \u0026gt;\u0026gt; 向右位移 A\u0026gt;\u0026gt;B   ~ 取1補數 ~A   課堂演練 在這邊我猜大家還是不太了解內容，那麼照舊我們依然從程式面去講解:\n#include \u0026lt;stdio.h\u0026gt;int main(){ /* C 語言中宣告各個進位方式: 二進位:0b+數字 八進位:0+數字 十進位:數字 十六進位:0x+數字 */ int a = 0b00001010;//10  int b = 0b00000011;//3  int c = 0x0; /* C 語言中printf各個進位之參數: 二進位:自己寫(...) 八進位:%o 十進位:%d 十六進位:%x */ printf(\u0026#34;a \u0026amp; b = %d\\n\u0026#34;, a \u0026amp; b); printf(\u0026#34;a | b = %d\\n\u0026#34;, a | b); printf(\u0026#34;a ^ b = %d\\n\u0026#34;, a ^ b); printf(\u0026#34;a \u0026lt;\u0026lt; b = %d\\n\u0026#34;, a \u0026lt;\u0026lt; b); printf(\u0026#34;a \u0026gt;\u0026gt; b = %d\\n\u0026#34;, a \u0026gt;\u0026gt; b); printf(\u0026#34;~c = %x\\n\u0026#34;, ~c); return 0; } "});index.add({'id':42,'href':'/docs/Ch3/03_assignment/','title':"03 Assignment",'content':"指派運算 指派這個概念其實其實相當的簡單，大家其實也已經知道甚至在使用了，最基本的指派運算子其實就是「=」。 等號可以幫助我們來將右邊的值給左邊的變數資料，但是其實等於可以跟更多的運算子合用，其會直接進行運算並存回左邊變數資料，如下。\n指派運算子  運算子 意義 舉例   = 指派 A = B   += 相加並指派 A += B   -= 相減並指派 A -= B   *= 相減並指派 A *= B   /= 相除並指派 A /= B   %= 取餘數並指派 A %= B   \u0026amp;= 且(and)並指派 A \u0026amp;= B   |= 或(or)並指派 A |= B   ^= 互斥或(xor)並指派 A ^= B   \u0026lt;\u0026lt;= 位元向左位移並指派 A \u0026lt;\u0026lt;= B   \u0026gt;\u0026gt;= 位元向右位移並指派 A \u0026gt;\u0026gt;= B   上述就是在指派的運算子部分，而在這邊我們利用一些較簡單的例子帶過，我相信大家應該可以可以理解以下程式內容，其餘指派運算子算法其實相同於案例就不在多加描述。\n#include \u0026lt;stdio.h\u0026gt;int main(){ int a = 5; int b = 2; printf(\u0026#34;a += b = %d\\n\u0026#34;, a += b); printf(\u0026#34;a -= b = %d\\n\u0026#34;, a -= b); printf(\u0026#34;a *= b = %d\\n\u0026#34;, a *= b); printf(\u0026#34;a /= b = %d\\n\u0026#34;, a /= b); printf(\u0026#34;a %%= b = %d\\n\u0026#34;, a %= b); return 0; } "});index.add({'id':43,'href':'/docs/Ch3/04_boolean/','title':"04 Boolean",'content':"布林運算  C 語言中並沒有布林*!*\n 布林運算 在這邊有個很重要的觀念要告訴大家，其實在C 語言中並沒有布林這型態，一定有很多同學在這邊會有疑問，那這章節是不是有寫錯了？，但其實這是一個 C 的重要觀念。\n 非零即為真。\n 希望大家對於這項觀念有一定的基本概念，那既然如此本章到底要講些什麼。 其實本章節主要是要教大家關係以及邏輯運算，因為在撰寫程式的過程中必然會遇到許多時候，我們會使用關係以及邏輯運算做為判斷的基準。所以這兩部份將會在下面進行詳細介紹。\n關係運算子 C 語言中的關係運算子都是二元運算子，所以也就是代表需要有兩個運算元來進行運算，而在關係運算子的回傳部分將會以 0 為假，1 為真。其中各項運算子包含\n 運算子 意義 舉例   \u0026lt; 小於 A \u0026lt; B   \u0026lt;= 小於等於 A \u0026lt;= B   \u0026gt; 大於 A \u0026gt; B   \u0026gt;= 大於等於 A \u0026gt;= B   == 相等 A == B   != 不相等 A != B   所以今天假設有一程式內容為:\n#include \u0026lt;stdio.h\u0026gt;int main(){ int a = 5; int b = 2; printf(\u0026#34;%d\\n\u0026#34;, a \u0026gt;= b); return 0; } 則該程式輸出則為1，這應該是非常淺而易見的，對吧？\n邏輯運算子 邏輯運算子在C 語言中其實並不多，僅僅只有三個運算子  運算子 意義 舉例   ! 非(not) !A   \u0026amp;\u0026amp; 且(and) A \u0026amp;\u0026amp; B   || 或(or) A || B   其中!則是代表A的相反，而或跟且則是像前面位元運算一樣的運作方式，就不在多進行舉例。\n補充  先乘除後加減 聽過吧？ 課程到了這部分其實C 語言中幾種比較常使用到的運算子都已經介紹完畢，但是還有一個在使用各項運算子時很重要的標準，也就是各個運算子的先後順序，就如同我們在寫算式會有先乘除後加減一般，其實在C 語言內也有類似的東西，但是它的內容更加的多元。\n.tg .tg-baqh{text-align:center;vertical-align:top}   運算子 結合規則   () [] -\u0026gt; . -\u0026gt;   ! ~ ++ -- + - * \u0026amp; (type) sizeof \u0026lt;-   * / % -\u0026gt;   + - -\u0026gt;   \u0026lt;\u0026lt; \u0026gt;\u0026gt; -\u0026gt;   \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= -\u0026gt;   == != -\u0026gt;   \u0026amp; -\u0026gt;   ^ -\u0026gt;   | -\u0026gt;   \u0026amp;\u0026amp; -\u0026gt;   || -\u0026gt;   ？: \u0026lt;-   = += -= /= %= \u0026amp;= \u0026lt;-   ^= |= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026lt;-   , -\u0026gt;   練習時間 想必大家一定看的眼花撩亂，不知道大家是否可以依據此表算出以下答案各為多少嗎？ ```C++ 5+2*3 4+(2-8)*45/2-5\n5\u0026laquo;(2+2)*5-3+4\n(14\u0026laquo;(2+1)*3+1)-5573\n"});index.add({'id':44,'href':'/docs/Ch3/05_ifStatement/','title':"05 if Statement",'content':"判斷式  如果今天颱風假，我就在家耍廢；否則我還是得來上課。\n 在程式內為了運用各式各樣的狀況，判斷式這樣東西的存在是非常重要的。 為了應付這種狀況，C 語言理所當然地也提供了很多條件判斷式。\nif條件判斷 最為基礎的則是if條件判斷，他的基本語法如下:\nif(條件){ do1; } else{ do2; } 所以如果拿我們最上面案例的話就會變成\nif(放颱風假){ 在家耍廢; } else{ 乖乖去上課; } 當然在必要時刻其實不一定有if就要有else 我們也可以只有一個if即可，例如:\nif(放颱風假){ 在家耍廢; } 有了最基礎的判斷式之後，其實可以做的事情就更多了\n練習 給大家一個實例的實作試試看: 假設今天輸入計概分數，分數\u0026gt;=60就顯示\u0026quot;及格\u0026rdquo;，\u0026lt;60則顯示\u0026quot;當掉\u0026rdquo;。那該如何利用最簡單的if else判斷式去做呢？\n解答 #include \u0026lt;stdio.h\u0026gt; int main(){ int score; scanf(\u0026#34;%d\u0026#34;,\u0026amp;score); if(score \u0026gt;=60){ printf(\u0026#34;及格!\u0026#34;); } else{ printf(\u0026#34;當掉!\u0026#34;); } return 0; } 巢狀if if只能判斷一件事情嗎? 答案當然是否定的。 當我們需要去對某個條件做多重確認的時候，其實可以在一層if內在寫上另一層的if，例如:\nif(放颱風假){ if(大風大雨){ 在家耍廢; } else{ 打球; } } else{ if(大風大雨){ 在家耍廢; } else{ 乖乖去上課; } } 以上面這個案例來看的話，他會先對\u0026quot;放颱風假\u0026quot;這件事情進行檢查，並根據條件的是否，進而去下一層檢查\u0026quot;大風大雨\u0026rdquo;，才來決定要做哪些事情。\n練習 計概分數本身如果分數 \u0026gt;100 或者 \u0026lt;0 這都是 不正常 的分數，所以應該要顯示 \u0026ldquo;不正常!\u0026rdquo; ，請大家根據前一個例子進行修改。\n當輸入分數在合理範圍內(即0~100間)則 \u0026gt;=60 就顯示 \u0026ldquo;及格\u0026rdquo;，\u0026lt;60 則顯示 \u0026ldquo;當掉\u0026rdquo;。\nif elseif else條件式 假設今天的分數我想要讓他有更多的區間呢? 我想各位不會想要一直用一堆的if去把它包起來吧\n而在C 語言裡面，除了基本的if else以外其實還有更多的用法。 也就是if elseif else的條件式，他的基本語法如下:\nif(條件1){ do1; } else if(條件2){ do2; } else{ do3; } 而在進行條件檢查時他會依序從上開始檢查，如果所有條件都不符合才會執行至else內部\n另外在中間部分的else if的數量其實是可以隨著程式的要求進而去做改變 也就是說可以有 零到多個 的else if在原先的if else條件判斷式中間。\n練習 再次根據上一個練習，請大家練習看看，假設計概分數合理範圍為0~100，當計概分數本身不在合理範圍內(即\u0026gt;100或\u0026lt;0)則顯示\u0026quot;不正常!\u0026quot;。\n在合理範圍內時，分數\u0026gt;=90就顯示\u0026quot;A\u0026rdquo;、介於80~89間則顯示\u0026quot;B\u0026rdquo;、介於60~79間則顯示\u0026quot;C\u0026rdquo;、\u0026lt;60則顯示\u0026quot;當掉\u0026rdquo;。\nswitch條件判斷 switch是C 語言提供的另一種條件判斷方式，本身只能比較數值或字元 但是使用適當的話，它可比 if 判斷式來得有效率；switch 的基本語法如下:\nswitch (變數名稱或運算式) { case 符合的數字或字元: do1; break; case 符合的數字或字元: do2; break; default: do3; } 其中程式再執行時會先看看 switch 的括號，當中置放要取出數值的變數，取出數值之後，會與case 設定的數字或字元比對，符合則執行該case 以下的陳述句直到遇到break為止 才會離開switch，若case內都沒有相符的則會執行default內的內容，但是default本身並不一定要存在，這部分跟if else中，其實可以不要寫else是一樣的。\n這樣講可能大家有點不可以很清楚的理解，假設今天有一個例子利用if elseif else寫法為:\nint a; if(a == 1){ //do1 } else if(a == 2) { //do2 } else if(a == 3) { //do3 } else{ //do4 } 那其實也可以將其代換成switch case的寫法如下:\nint a; switch(a) { case 1: //do1  break; case 2: //do2  break; case 3: //do3  break; default: //do4 } 當然if跟switch之間並不是具有那麼強烈的優異性，只是遇到複合條件時，switch 就幫不上忙了，你無法在 switch 中組合複雜的條件陳述。 這時後使用 if 就會是比較好的方式，理所當然的，if 與 switch 兩者也可以搭配著靈活使用。\n練習 一樣的計概分數題目\n假設計概分數合理範圍為0~100 當計概分數本身不在合理範圍內(即\u0026gt;100或\u0026lt;0)則顯示\u0026quot;不正常!\u0026rdquo; 在合理範圍內時「分數\u0026gt;=90」就顯示 \u0026ldquo;A\u0026rdquo;、介於80~89間則顯示 \u0026ldquo;B\u0026rdquo;、介於60~79間則顯示 \u0026ldquo;C\u0026rdquo;、\u0026lt;60則顯示\u0026quot;當掉\u0026rdquo;。\n大家是否能把它改成switch case的寫法呢?\n"});index.add({'id':45,'href':'/docs/Ch3/06_practice/','title':"06 Practice",'content':"練習 練習 3-1 請輸入三個數字A、B即C 並讓程式幫你印出 以下圖片三個式子的輸出值\n練習 3-2 請模擬一次性販賣機，讓使用者輸入金額，並選擇a~d四種產品，若能夠購買則顯示購買成功並顯示退幣，若錢不夠則顯示購買失敗，販賣機商品及價錢請參考下表。\n   商品代號 價錢     a 10   b 50   c 100   d 87    例子1\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：a 商品a購買成功，退幣40元  例子2\n請投入金額：50 a:10 b:50 c:100 d:87 請輸入商品代號：d 商品d購買失敗  "});index.add({'id':46,'href':'/docs/Ch3/Intro/','title':"Intro",'content':"Chapter 3：扮裝行列 Operation  printf玩膩了?，該來一些邏輯運算了。\n 教學目標  各式運算式入門 基礎的運算子、運算子教學 判斷式的使用  子章節   算數運算  位元運算  指派運算  布林運算  判斷式  練習  助教群的話 終於開始有些好玩的東西出現了(?)\n"});index.add({'id':47,'href':'/docs/Ch4/01_loop/','title':"01 Loop",'content':"迴圈 有時候我們需要讓程式重複做某一件事情，我們可以藉由兩種方法做到，一是迴圈，二是遞迴，因為遞迴太過麻煩且不易使用所以在此不做贅述，留待未來。\n在C++中使用迴圈和C語言相同，使用while及for。\nwhile while使用方式為，小括號內為繼續執行條件，大括號為執行動作。\n假設我們想讓使用者持續輸入數字，並使這些數字相加，當總和大於100時結束，請參考範例10-8：\n範例 4-1 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int sum = 0,num; while(sum \u0026lt;= 100){ printf(\u0026#34;please input a number to sum:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;num); sum = sum + num; printf(\u0026#34;The \\\u0026#34;sum\\\u0026#34;is %d\\n\u0026#34;,sum); } return 0; } 練習4-1  請參考範例10-8，使用While 改為讓使用者輸入5次數字後印出數字總和並結束程式。\n 一般迴圈我們都會做三件事情，設定條件變數、設立終止條件、更改條件變數，以範例10-8為例子： 設定條件變數：int sum = 0; 設立繼續條件：sum \u0026lt;= 100 更改條件變數：sum = sum + num;\n我們更常會遇到的是如同練習10-8的狀況，條件變數是持續+1，所以我們就有了for的使用。\nfor for的使用方式為，小括號內依序放入條件變數設定、繼續條件設立、條件變數更改，並用;隔開，大括號內為執行動作。\n範例10-9為顯示2的九九乘法表\n範例4-2 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i; for(i=1;i\u0026lt;10;i++){ printf(\u0026#34;2*%d=%2d\\n\u0026#34;,i,2*i); } return 0; } 練習4-2  請利用雙層迴圈(for)印出完整的九九乘法表，並排版。\n do-while do-while的意義為不論如何都先做一次迴圈內的事情，再進行while迴圈，但個人經常失誤，所以不推薦使用，請參考範例4-3\n範例4-3 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; int main(){ int flag=0,user,prog; srand(time(NULL)); do{ printf(\u0026#34;please input your hand(3\u0026gt;2,2\u0026gt;1,1\u0026gt;3):\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;user); prog = rand()%3+1; if( (prog-user == -2)||(prog-user == 1) ){ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;you lose\\n\u0026#34;); }else if( (user-prog == -2)||(user-prog == 1) ){ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;you win\\n\u0026#34;); flag = 1; }else{ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;draw\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); }while(flag==0); return 0; } 以上程式不容易看出do-while的效果，但有其他可以講的概念。srand()為亂數種子，是為了讓亂數依據一個方式變動的函式，rand()會產生出極大的隨機亂數，使用%即可以控制他的範圍。flag(旗標)是我們常常拿來做流程控管的方法，但旗標太多程式也會雜亂，所以不推薦使用太多，程式底層會常常使用到旗標的概念。\n練習4-3  請思考有什麼情況使用do-while比while好\n break 範例4-4 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; int main(){ int user,prog; srand(time(NULL)); while(1){ printf(\u0026#34;please input your hand(3\u0026gt;2,2\u0026gt;1,1\u0026gt;3):\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;user); prog = rand()%3+1; if( (prog-user == -2)||(prog-user == 1) ){ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;you lose\\n\u0026#34;); }else if( (user-prog == -2)||(user-prog == 1) ){ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;you win\\n\u0026#34;); break; }else{ printf(\u0026#34;program: %d\\n\u0026#34;,prog); printf(\u0026#34;you : %d\\n\u0026#34;,user); printf(\u0026#34;draw\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 範例4-4和範例4-3一樣，皆為猜拳的程式，但4-4使用了無限迴圈，並使用break跳出迴圈代替旗標的功能。 範例4-5會介紹continue的用法。\ncontinue 範例4-5 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i; for(i=0;i\u0026lt;100;i++){ printf(\u0026#34;%d:\u0026#34;,i); if(i%5 == 0){ printf(\u0026#34;i am 5\\n\u0026#34;); continue; } printf(\u0026#34;i am not 5\\n\u0026#34;); } return 0; } continue的意義為馬上重新執行迴圈，有別於break的跳出迴圈。\n練習  請讓使用者輸入高度，印出三角形，字元不限，如下所示 input:3 \u0026ndash;@\u0026ndash; -@@@- @@@@@\n "});index.add({'id':48,'href':'/docs/Ch4/02_array/','title':"02 Array",'content':"陣列 陣列將同一型態同一作用的變數排在一起，請參考範例4-6。\n範例4-6 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i,array[5]; for(i=0;i\u0026lt;5;i++){ printf(\u0026#34;%d:\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;array[i]); } printf(\u0026#34;\\n\u0026#34;); for(i=0;i\u0026lt;5;i++){ printf(\u0026#34;%d:%d\\n\u0026#34;,i,array[i]); } return 0; } 我們以int array[5]宣告出一個變數名稱為array並存著五個int值的陣列，而陣列索引值從 0 開始。我們通常都會使用for迴圈將值依序瀏覽並進行操作。\n範例4-7為二維陣列的作法，三維四維的作法同理可證，請自行練習\n範例4-7 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i,j,grade[5][3]; for(i=0;i\u0026lt;5;i++){ for(j=0;j\u0026lt;3;j++){ printf(\u0026#34;%d,%d:\u0026#34;,i,j); scanf(\u0026#34;%d\u0026#34;,\u0026amp;grade[i][j]); } } printf(\u0026#34;\\n\u0026#34;); while(1){ printf(\u0026#34;please input 0~4: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); if(i\u0026gt;-1 \u0026amp;\u0026amp; i\u0026lt;5){ printf(\u0026#34;English:%d\\n\u0026#34;,grade[i][0]); printf(\u0026#34;Chinese:%d\\n\u0026#34;,grade[i][1]); printf(\u0026#34;ComputerScience:%d\\n\u0026#34;,grade[i][2]); } } return 0; } 泡沫排序法 泡沫排序法是最容易學與最容易實作的排序法，如圖所示，假設我們要將陣列由小排到大，首先比前兩個，若前一個比較大則交換，接著比較二三個，若前面比較大則交換，直到將最大的排到最後面，在從頭進行一次排出次大的。如範例4-8。\n 範例4-8 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i,j,k,temp; int test[5]={4,3,2,5,1}; for(i=0;i\u0026lt;5-1;i++){ for(j=0;j\u0026lt;5-i-1;j++){ //see progress  printf(\u0026#34;\\ni,j:%d,%d : \u0026#34;,i,j); for(k=0;k\u0026lt;5;k++){ printf(\u0026#34;%d \u0026#34;,test[k]); } //end  if(test[j]\u0026gt;test[j+1]){ temp = test[j]; test[j] = test[j+1]; test[j+1] = temp; printf(\u0026#34;swap\u0026#34;); } } } //see end  printf(\u0026#34;\\nend : \u0026#34;,i,j); for(k=0;k\u0026lt;5;k++){ printf(\u0026#34;%d \u0026#34;,test[k]); } //end \treturn 0; } 練習4-8  請參考範例4-8，改動ｉ和ｊ雙重迴圈的變數使結果依然正確\n 選擇排序法 選擇排序法直接找到最大的數的位子，將其放置正確的位置。如圖所示：\n 範例4-9 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ int i,j,k,temp,num; int test[5]={4,3,2,5,1}; for(i=4;i\u0026gt;-1;i--){ //see progress  printf(\u0026#34;\\n%d : \u0026#34;,5-i); for(k=0;k\u0026lt;5;k++){ printf(\u0026#34;%d \u0026#34;,test[k]); } //end  num=0; for(j=0;j\u0026lt;i+1;j++){ if(test[num]\u0026lt;test[j]){ num=j; } } temp = test[num]; test[num] = test[i]; test[i] = temp; } //see end  printf(\u0026#34;\\nend:\u0026#34;); for(k=0;k\u0026lt;5;k++){ printf(\u0026#34;%d \u0026#34;,test[k]); } //end \treturn 0; } "});index.add({'id':49,'href':'/docs/Ch4/Intro/','title':"Intro",'content':"Chapter 4：循環演算 Loop \u0026amp; Array "});index.add({'id':50,'href':'/docs/Ch5/01_string/','title':"01 String",'content':"字串 在大部分語言中，字串會使用string類別儲存，在C語言中則是用char陣列表示，再使用printf(\u0026quot;%s\u0026quot;,string);印出，請參考範例5-1\n字串IO 範例5-1 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ unsigned char str[11] = \u0026#34;HelloWorld\u0026#34;; printf(\u0026#34;%s\u0026#34;,str); return 0; } HelloWorld中有十個字元，而字串有終止字元('\\0')，所以我們必須大小宣告為11才能完整的放入HelloWorld。\n練習5-1  請參考範例5-1將str陣列大小改變看會有什麼結果\n 使用printf(\u0026quot;%s\u0026quot;,str);進行字串輸出，使用scanf(\u0026quot;%s\u0026quot;,str);進行字串輸入，要注意此時str沒有加上\u0026amp;，請參考範例5-2\n範例5-2 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ char str[100]; printf(\u0026#34;please input:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;your input:%s\\n\u0026#34;,str); return 0; } 請注意，scanf(\u0026quot;%s\u0026quot;,str);，沒有加\u0026amp;，原因與指標有關，將於之後更詳細說明。\n練習5-2  請使用範例5-2，請嘗試使用各種輸入並觀看其結果。\n 注意：輸入\u0026rsquo; \u0026lsquo;時只會將前半段讀入，在scanf()中\u0026rsquo; \u0026lsquo;也是終止的字元之一，若要避免此情況可以使用scanf(\u0026quot;%[^\\n]\u0026quot;,s);，scanf()還有很多特殊寫法，但因為不常用到故不再多做敘述。\n中文字佔兩個Bytes，我們可以將char以十六進位的方式印出用以表示，請參考範例5-3。\n範例5-3 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(){ unsigned char str1[3] = \u0026#34;逢\u0026#34;,str2[3]; printf(\u0026#34;%s\\n\u0026#34;,str1); printf(\u0026#34;%X,%X\\n\\n\u0026#34;,str1[0],str1[1]); str2[0]=0xB3; str2[1]=0x7B; str2[2]=\u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;,str2); return 0; } 由範例5-3可以得知，\u0026ldquo;逢\u0026quot;字由0xB3和0x7B組成，我們從str2直接存值進入，再以字串形式印出，也的確是同一個字，'\\0'則是終止符號，當讀到此字元時停止印出。\n練習5-3  請設計一個程式證明printf()讀到\u0026rsquo;\\0'時停止。\n function使用 引入string.h後有許多方便的函式可以使用，詳細可以查官方文件。以下將會介紹幾個function的範例，若有疑慮可以於網路上搜尋更多範例。\nstrlen #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main(){ char str[100]; int len; printf(\u0026#34;please input any string:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str); len = strlen(str); printf(\u0026#34;\\\u0026#34;%s\\\u0026#34;\\\u0026#39;s size is %d\u0026#34;,str,len); return 0; } strlen會回傳字串的長度，藉由範例可以多多嘗試。\nstrcpy #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ char str[100],str2[100]; int len; printf(\u0026quot;please input any string in str2:\u0026quot;); scanf(\u0026quot;%s\u0026quot;,str2); strcpy(str,str2); printf(\u0026quot;after strcpy\\(str,str2\\)\\nstr:\\\u0026quot;%s\\\u0026quot;\\n\u0026quot;,str); return 0; } strcpy會讓str的資料等於str2的資料，並非直接寫str = str2;，後者使str2和str存取同一個陣列，而非複製出另一個相同的字串。\nstrcat #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main(){ char str[100],str2[100]; int len; printf(\u0026#34;please input any string1:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;please input any string2:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str2); strcat(str,str2); printf(\u0026#34;after strcat\\(str,str2\\)\\nstr:\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;,str); return 0; } strcat將str的尾端接上str2。\nstrstr #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main(){ char str[] = \u0026#34;the git book is very convenience.\u0026#34;; char str2[]= \u0026#34;book\u0026#34;; char* temp; printf(\u0026#34;str:\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;,str); printf(\u0026#34;str2:\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;,str2); temp = strstr(str,str2); printf(\u0026#34;after temp = strstr\\(str,str2\\)\\ntemp:\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;,temp); return 0; } strstr會在str中找到等於str2的第一個位址，並將該值回傳，有關位址和指標請詳見本書第七章。\nstrcmp #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main(){ char str[100]; char str2[] = \u0026#34;OpenSesame\u0026#34;; printf(\u0026#34;please input the password:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;the strcmp\\(str,str2\\) is %d\\n\u0026#34;,strcmp(str,str2)); if(!strcmp(str,str2)){ printf(\u0026#34;door opening.\\n\u0026#34;); }else{ printf(\u0026#34;nothing happened.\\n\u0026#34;); } return 0; } strcmp會讓str減str2，若大於回傳1，小於回傳-1，等於回傳0，這使得我們可以對字串進行大小比較甚至排序。\nstrcmp練習  請宣告可以存取5個字串的陣列，讓使用者分別輸入值，接著排序後印出\n strspn #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main(){ char str[100]; char str2[] = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; printf(\u0026#34;str2 :%s\\n\u0026#34;,str2); printf(\u0026#34;str :\u0026#34;); scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;the strspn\\(str,str2\\) is %d\\n\u0026#34;,strspn(str,str2)); return 0; } strspn會回傳str有幾個字元被包含於str2，直到第一個沒有被包含的為止。\n"});index.add({'id':51,'href':'/docs/Ch5/02_bignumber/','title':"02 Bignumber",'content':""});index.add({'id':52,'href':'/docs/Ch5/Intro/','title':"Intro",'content':"Chapter 5：情報強化 String "});index.add({'id':53,'href':'/docs/Ch6/Intro/','title':"Intro",'content':"Chapter 6：三千世界 Functions 中文：副程式、副函式、函式、函數\n一、Introduction 介紹 一般來說，程式啟動時從程式進入點開始，即 main 的所在位置，從以前到現在，我們程式也都是寫在 main 裡面。例如下方這個程式：\nint main() { printf(\u0026#34;hello world!\\n\u0026#34;); return 0; } 不過，有時候我們會有一些重複的程式碼，舉例來說，我們可能常常用到次方這個計算，這時候我們就能用 Function 來減少程式碼的數量，而且若是需要修改計算方式的話，不需要每個地方都修改，增加維護性。其實，說穿了就是各位在數學上都有學習過的函數。y = f(x)，只是現在用 C 來表達。\n接著，我們就來學習如何撰寫 Function 吧！\n二、Definition 定義 1.本體寫法： 根據定義，Function 的本體寫法為：\nreturn_type function_name( parameter list ) { body of the function } 舉例來說，次方的 Function 可以寫成這樣：\nint pow(int base, int power) { int i, sum = base; for (i = 1; i \u0026lt; power; i++) { sum = sum * base; } return sum; } 2.宣告方式： 宣告原型為：\nreturn_type function_name( parameter list ); 例如以下這個 Function：\nint pow(int base, int power); 應該寫成這樣：\nint pow(int, int); 3.位置的藝術 一般來說，Function 必須先宣告，再寫本體。不過若是寫在 main 主程式的上面，就不必再寫宣告。\n正確： void f1(void) { ... } int main(void) { f1(); } void f1(int); int main(void) { f1(); } void f1(int n) { ... } void f2(void) { ... } void f1(int n) { f2(); } int main(void) { f1(); } 錯誤： int main(void) { f1(); } void f1(int n) { ... } void f1(int n) { f2(); } void f2(void) { ... } int main(void) { f1(); } 4.沒有輸入或輸出 Function 是可以接受沒有輸入或輸出的，以下這幾種寫法都會成立：\nvoid pow(int base, int power) { ... } int pow(void) { ... } void pow() { ... }  練習 6-1 請設計一個 Function，功能為輸入兩個數字，回傳兩者相加。\n練習 6-2 請設計一個 Function，功能為印出 \u0026ldquo;hello world!\u0026rdquo; 10 次。\n 三、Function 的輸入陷阱 假設我們要設計一個 Function，功能為交換兩個整數值。例如：\nx = 5, y = 10，當我們呼叫 swap(x,y); 之後會變成 x = 10, y = 5。\n這時大家可能會這樣寫：\nvoid swap(int x, int y) { int tmp; tmp = x; x = y; y = tmp; } int main() { int x = 5, y = 10; printf(\u0026#34;Before : x = %d, y = %d\\n\u0026#34;, x, y ); swap(x, y); printf(\u0026#34;After : x = %d, y = %d\\n\u0026#34;, x, y ); return 0; } 但是執行後卻發現，Before 和 After 是一樣的，意味著值沒有被交換，為什麼？\n這是因為，C 語言的 Function 在處理輸入時，其實是在另外一個記憶體位址宣告一個變數，縱使變數名稱是一樣的，代表的卻是不同變數。\n那要怎麼樣處理這個問題呢？我們在下一章「指標 Pointer」中將會介紹使用方式。\n四、Function 進階用法：Recursion 遞迴 ###「遞迴只應天上有，凡人該當用迴圈」\n通常要做一件事情，我們會用迴圈，例如要寫一個程式，功能為「1 加到 n」\nint sum(int n) { int i; int tmp = 0; for (i = 0; i \u0026lt; n; i++) tmp = tmp + (i + 1); return tmp; } 不過我們可以利用 Function 回傳值可以呼叫 Function 的特性，達到一種不斷呼叫自己的感覺。這種使用方式稱為遞迴（Recursion）\nint sum(int n) { if (n==1) return 1; else return sum(n-1) + n; } 這是一種抽象的概念，如果我們要計算 sum(10)，程式會這樣跑：\n1.第一次，程式會 return sum(9) + 10;。\n2.於是，要計算 sum(10) 必須先計算 sum(9)，而 sum(9) 則 return sum(8) + 9;。\n3.不斷如此下去，最後到 return sum(1) + 2; 的時候，對於 sum(1)，程式判斷到 n == 1，直接 return 1;。\n4.於是 sum (2) 回傳 1 + 2，sum(3) 則回傳 3(1+2) + 3，sum(4) 則回傳 6(1+2+3) + 4，如此下去，我們得到 sum(10) 的答案。\n 練習 6-3 請設計一個 Recursive Function，功能為輸入 3 印出 123，輸入 5 印出 12345。\n加分練習 6-4 同上題，不過不能另外寫 Function，不能使用迴圈語法。\n "});index.add({'id':54,'href':'/docs/Ch7/Intro/','title':"Intro",'content':"Chapter 7：鬼門遁甲 Pointer 中文：指標\n一、Introduction 介紹 指標，是 C 語言中最強而有力的一項特性，也是最多人放棄的一個地方。指標有強力，而且高效能的優點，卻也伴隨著難以撰寫、難以入門、難以理解、難以維護的缺點。其寫法千變萬化，令人嘆為觀止。但是不要怕，只要搞懂了指標的定義，你就踏出成功的第一步了。\n在介紹指標之前，讓我們複習一下變數（Variable）這個機制是如何運作的。\n變數提供了一個有名稱的記憶體位址，當我們宣告 int x = 0; 的時候，其實是系統在記憶體當中找一塊 int 大小的空間，記錄下記憶體位址（像是 0x23ff12，每次不一樣），名稱設為 x。\n取址運算子（Address-of operator） 如果我們想知道變數的記憶體位址，可以使用取址運算子「\u0026amp;」：\nint main(void) { int x = 10; printf(\u0026#34;Value of x : %d\\n\u0026#34;, x); printf(\u0026#34;Address of x : %p\\n\u0026#34;, \u0026amp;x); return 0; } 執行結果為：\nValue of x : 10 Address of x : 0x23ff12 也就是說，記憶體位置 0x23ff12 這個地方放著 10，這個地方的名字叫做 x。\n而我們這章節要介紹的 Pointer 指標，是一種型態，專門儲存記憶體位址。就像是一個指標指向某一個地方。簡單來說，指標指向記憶體位址。\n二、Definition 定義 宣告方式 指標的宣告方式為：\ntype *ptr; 例如：\nint *ptr; float *ptr2; char *ptr3; 宣告指標必須宣告型態，讓 Compiler 可以知道目標記憶體位址上的資料要如何解釋。\n三、How to use 使用方式 我們必須把指標指向某個記憶體位址，可以這樣寫：\nint x = 10; int *ptr = \u0026amp;x; 或是\nint x = 10; int *ptr; ptr = \u0026amp;x; 這樣子寫，代表宣告 ptr 是一個 int 型態的指標，指向變數 x 的記憶體位址。\n提取運算子（Dereference） 如果要取得這個記憶體的值，我們要用 * 提取運算子。\nint x = 10; int *ptr \u0026amp;x;; printf(\u0026#34;The value of x : %d\\n\u0026#34;, x); printf(\u0026#34;The value of address where ptr point : %d\\n\u0026#34;, *x); 執行結果為：\nThe value of x : 10 The value of address where ptr point : 10 如果我們把全部都 print 出來比較的話：\nint x = 10; int *ptr = \u0026amp;x;; printf(\u0026#34;The value of x : %d\\n\u0026#34;, x); printf(\u0026#34;The address of x : %p\\n\u0026#34;, \u0026amp;x); printf(\u0026#34;The address where ptr point : %p\\n\u0026#34;, ptr); printf(\u0026#34;The value of address where ptr point : %d\\n\u0026#34;, *ptr); printf(\u0026#34;The address of pointer ptr : %p\\n\u0026#34;, \u0026amp;ptr); 執行結果應該會像以下：\nThe value of x : 10 The address of x : 0x12fe1e The address where ptr point : 0x12fe1e The value of address where ptr point : 10 The address of pointer ptr : 0xfa131a 不要忘記指標也擁有自己的記憶體位址。\n 練習 7-1 設計一個 float 型態的指標，並且像範例一樣 print 出來看看位址與數值。\n 四、指標的特性 我們寫了一個以下的程式：\nint x = 10; int *ptr = \u0026amp;x; 並且對 ptr 所指向的值做修改：\n*ptr = 20; 這時候值會如何變化呢？我們 print 出來看看：\nprintf(\u0026#34;The value of address where ptr point : %d\\n\u0026#34;, *ptr); printf(\u0026#34;The value of x : %d\\n\u0026#34;, x); 執行結果如下：\nThe value of address where ptr point : 20 The value of x : 20 由於指標 ptr 指向的記憶體位址和變數 x 所代表的記憶體位址是同樣的，於是我們修改了 ptr 指標所指向的記憶體位址的值，也同樣修改了變數 x 的值。\n實務上，這種特性可以讓你有許多種用法，其中一種最基本的，就是拿來解我們在上一章節所提到的 Function 問題。\n五、解 Function 的輸入陷阱 上一章提到，假設我們要設計一個 Function，功能為交換兩個整數值，會遇到一些問題，原因是在 Function 中使用的變數和外面的變數是不同的，為了解決這個問題，我們必須使用上述指標的特性。\n愚蠢的你大概還沒想到怎麼做，簡單說，就是我們把記憶體位址當作 Function 的參數傳進去！\n原本的程式應該是這樣：\nvoid swap(int x, int y) { int tmp; tmp = x; x = y; y = tmp; } int main() { int x = 5, y = 10; printf(\u0026#34;Before : x = %d, y = %d\u0026#34;, x, y ); swap(x, y); printf(\u0026#34;After : x = %d, y = %d\u0026#34;, x, y ); return 0; } 我們改成這樣：\nvoid swap(int *x, int *y) { int tmp; tmp = *x; *x = *y; *y = tmp; } int main() { int x = 5, y = 10; printf(\u0026#34;Before : x = %d, y = %d\\n\u0026#34;, x, y ); //傳記憶體位址進去 \tswap(\u0026amp;x, \u0026amp;y); printf(\u0026#34;After : x = %d, y = %d\\n\u0026#34;, x, y ); return 0; } 執行結果：\nBefore : x = 5, y = 10 After : x = 10, y = 5 x, y 成功被交換了！如果你不知道為什麼，從頭再看一次指標的定義吧！\n六、指標的安全問題 說起來，這麼強大的武器就像雙面刃一樣，指標的好處是可以快速的直接進行記憶體存取，然而壞處卻也相同。萬一不小心修改到不應該修改的地方，程式可是會直接掛掉的。更慘的是，由指標所造成的 bug 通常很難被找到，甚至是修復。在這裡，我們稍微學習一下關於指標的安全問題。\n1.釋放不用的指標 為了避免有許多已不必要的指標掌控著記憶體，指標若不使用就應該被釋放掉。使用方式很簡單，使用 free() 函式即可。使用 free() 釋放指標後，記憶體空間將被歸還給系統，避免程式占用大量記憶體。\nint *ptr; ... free(ptr); 2.宣告指標後，要指向 void 或其他地址 假設有一程式如下：\nint *ptr; *ptr = 10; 這將會發生大問題，為什麼？\n當宣告了一個指標後，代表某一塊記憶體空間被拿來當作是 int 型態指標的空間，但是這個空間原本可能有某些資料沒有被清掉。於是，你的指標正指向一個未知的區域，有時候不小心就可能造成大問題。\n所以最好都先給 void。\n七、動態記憶體配置 到目前為止我們都是講述一般的記憶體配置方式，假若需要一塊整數空間，我們就宣告 int 變數；需要 10 個，我們就宣告 int 陣列。不過，這樣的使用方式無法滿足實務上的需求。\n例如，今天我們需要寫一個校務系統，但沒辦法確定每年的學生人數都一樣。這時候用陣列，如果人太少，就浪費空間；人太多，根本不夠用。我們沒辦法提前知道要多少記憶體空間，只能見招拆招。這時候用到的，就是動態記憶體配置。\n1.malloc() 2.calloc() 3.realloc() 八、真正的指標 上述提到的用法，對於各位來說真正有用的應該只有在 Function 的部分，各位可能有很多疑問，這東西這麼抽象，這麼難學，到底有什麼用？別急，接著就是要教你指標的各種型態。\n1.指標與陣列 2.指標與字串 3.指標與結構 4.指標與函數 "});index.add({'id':55,'href':'/docs/Ch8/01_basic/','title':"01 Basic",'content':"基礎結構 在Ｃ語言中，我們可以利用結構來做很多事情，不過結構到底是啥呢？\n為何要用結構？ 在先前寫的一些範例中，我們的程式會有越來越多的變數宣告，以最常見的成績系統範例來說，大多都長得像這樣：\nint main() { int chinese_score[100], math_score[100], english_score[100]; char student_name[100][20], student_sex[100]; double student_average[100]; // ... } 結構可以協助我們將相同或相關的變數整合成一個，讓我們可以更輕鬆地去閱讀程式碼、更方便地去撰寫程式。\n以上面這例子來講，所有的score、name、sex、average都是學生的資料，而我們把這些資料分開來存，會讓我們在後續的資料處理會有相當程度的障礙。\n因此我們可以運用結構，將上面的例子變成：\nint main() { struct Student stu[100]; // ... } 這樣，我們在存取學生資料時，只要到stu的某一項去尋找就好了，不必在各個變數中來回尋找。\n 在C語言中，結構體(struct)指的是一種資料結構，是C語言中聚合數據類型(aggregate data type)的一類。結構體可以被聲明為變量、指針或數組等，用以實現較複雜的資料結構。結構體同時也是一些元素的集合，這些元素稱為結構體的成員(member)，且這些成員可以為不同的類型，成員一般用名字訪問。 \u0026ndash; Wikipedia\n 原型宣告 結構的原型宣告建議寫在int main()之外、，所有函式宣告之上，避免錯誤。 基本上，結構的定義會長得像這個樣子：\nstruct tag { member-list } variable-list ; 實際上宣告則會是這樣：\nstruct Student { char name[20]; char sex; int chinese_score; int math_score; int english_score; double average; } stu[100]; 其中，Student 就是 tag，中間所有的變數就是 member-list（成員列表），而 stu[100] 就是宣告的 variable-list 。\n在Ｃ語言中的結構，成員的型態可以不相同；結構可以不寫tag，但必須在原型宣告時宣告變數；variable-list 也可以為空，但這時你就必須有 tag。\n結構變數宣告 你可以在原型宣告的時候就宣告好變數，不過當然你也可以在主函式或其他函式中宣告，宣告的定義如下：\nstruct tag variable-list; 以上面的 Student 結構來講，宣告一個變數名為 s：\nstruct Student s; "});index.add({'id':56,'href':'/docs/Ch8/02_operation/','title':"02 Operation",'content':"結構操作 一般的結構變數，可以直接將結構變數當成一般變數來使用。\n成員取值 如果我們想要取得一個結構變數中的成員的值，可以運用「 . 」這個運算子，以前一章的 Student 結構為例子：\nstruct Student { char name[20]; char sex; int chinese_score; int math_score; int english_score; double average; }; int main() { struct Student s; } 當我們想要存取 s 的 name（名字）的時候，就可以這樣寫：\n// 輸入 scanf(\u0026#34;%s\u0026#34;, s.name); // 賦值 strcpy(s.name, \u0026#34;Danny\u0026#34;); // 輸出 printf(\u0026#34;%s\u0026#34;, s.name); 變數初始化 結構變數的初始化方法非常簡單，一樣在宣告的同時，運用{ }、.、,三者結合即可，範例如下：\nstruct Student s = { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }; 每個成員前面都要加.，成員之間則用,隔開，前後則用{ }夾起來。\n複製結構 結構變數跟一般變數具有相似性質，一般變數能做的，結構變數大多也能做，例如常見的「賦值」。\n我們可以直接將已經有資料的結構變數，賦予給一個沒有資料的結構變數，如此一來就可以達到「複製」的效果。\nstruct Student s = { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }, t; t = s; 此時，t 裡面的內容會跟 s 一模一樣，我們可以來檢查看看：\nprintf(\u0026#34;%s\\n\u0026#34;, s.name); printf(\u0026#34;%s\\n\u0026#34;, t.name); 各位也可以自行檢查其他成員的值是否相同。\n傳遞結構變數 結構變數也可以正常地丟進一般變數中，舉例來說，如果我想傳入一個 Student 結構變數去計算平均，我們可以這樣寫：\ndouble calc_average(struct Student stu) { return (stu.chinese_score + stu.math_score + stu.english_score) / 3.0; } int main() { struct Student s = { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }; s.average = calc_average(s); // ... } 又或者，你可以連回傳都不要，讓函式計算完直接幫你塞回去：\ndouble calc_average(struct Student *stu) { (*stu).average = ((*stu).chinese_score + (*stu).math_score + (*stu).english_score) / 3.0; // Or  // stu-\u0026gt;average = (stu-\u0026gt;chinese_score + stu-\u0026gt;math_score + stu-\u0026gt;english_score) / 3.0; } int main() { struct Student s = { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }; calc_average(\u0026amp;s); // ... } 自定義型態 有時候你會覺得struct Student打起來很長，用起來很煩、寫起來很煩，有沒有更簡單的寫法？\n有，當然有，我們可以透過 typedef 來自定義型態，typedef的定義如下：\ntypedef struct tag { member-list } type-name ; 舉例來說，以上面的 Student 結構來講，我們可以自定義一個 Student 型態：\ntypedef struct _Student { char name[20]; char sex; int chinese_score; int math_score; int english_score; double student_average; } Student; 而此時我們可以透過型態來宣告變數，也可以透過結構來宣告變數：\n// 這兩個宣告出來的東西是一樣的 Student a; struct _Student b; 初始化方式和原本一樣，而且，這兩個變數也是可以互相等號（賦值）的：\nStudent a = { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }; struct _Student b; b = a; 存取方式也和結構變數一樣，利用.來做成員取值：\nStudent s= { .name = \u0026#34;Peter\u0026#34;, .sex = \u0026#39;M\u0026#39;, .chinese_score = 63, .math_score = 98, .english_score = 87, .average = 82.666666 }; // 輸入 scanf(\u0026#34;%s\u0026#34;, s.name); // 賦值 strcpy(s.name, \u0026#34;Danny\u0026#34;); // 輸出 printf(\u0026#34;%s\u0026#34;, s.name); "});index.add({'id':57,'href':'/docs/Ch8/03_ptr_structure/','title':"03 Ptr Structure",'content':"結構指標 又是指標？\n沒錯，又是指標！\n在Ｃ語言中，結構也可以定義指標，我們稱它為「結構指標」，結構指標是我們未來實作一些「資料結構」的基礎。\n指標宣告 以上一章節 typedef 後的結構為例：\ntypedef struct _Student { char name[20]; char sex; int chinese_score; int math_score; int english_score; double student_average; } Student; 宣告的方法就跟一般變數一樣，加個星號*就好：\n// 兩者是一樣的 Student *a; struct _Student *b; 兩者都需要給予記憶體空間才能存放資料，否則都只能存記憶體位址，使用完畢也要使用free()來釋放空間。\n// 兩種寫法是一樣的 a = (Student *)malloc(sizeof(Student)); free(a); b = (struct _Student *)malloc(sizeof(struct _Student)); free(b); 成員取值 結構指標取值的方法有兩種，一個是跟結構變數一樣的用.，另一個則是用-\u0026gt;。\n以下都採用 Student *a 作為範例：\n// 輸入 scanf(\u0026#34;%s\u0026#34;, (*a).name); scanf(\u0026#34;%s\u0026#34;, a-\u0026gt;name); // 賦值 strcpy((*a).name, \u0026#34;Danny\u0026#34;); strcpy(a-\u0026gt;name, \u0026#34;Danny\u0026#34;); // 輸出 printf(\u0026#34;%s\u0026#34;, (*a).name); printf(\u0026#34;%s\u0026#34;, a-\u0026gt;name); 兩種寫法都可以，不過要注意的是，由於.這個運算子的優先權大於*，因此在使用時務必將 *a 用 ( ) 夾起來。\n為了避免忘記，我們會建議各位未來在使用結構指標時，一律使用 -\u0026gt;。\n"});index.add({'id':58,'href':'/docs/Ch8/04_practice/','title':"04 Practice",'content':"練習 練習 8-1 請試著用結構宣告一個球，這顆球包括他的半徑、顏色。\n練習 8-2 以練習 8-1 的結構，完成「計算球體積」、「計算球表面積」這兩個函式。\n"});index.add({'id':59,'href':'/docs/Ch8/Intro/','title':"Intro",'content':"Chapter 8：七夜怪談 Structure 教學目標  瞭解結構存在的意義 瞭解結構如何宣告及使用。 能將結構用在日常的程式練習中。  子章節   基礎結構  結構操作  結構指標  練習  "});index.add({'id':60,'href':'/docs/Ch9/Intro/','title':"Intro",'content':"Chapter 9：剪紙成兵 File I/O 檔案處理 C本身提供了許多檔案的輸入與輸出，以方便使用者設計與檔案有關的系統函數。\n其中包含了開檔、讀檔以及寫檔\u0026hellip;等\n簡單來說有以下這些\n   函數名稱 功能說明     fopen( ) 開啟一個檔案   fclose( ) 關閉一個檔案   putc( ) 輸出一個字元到檔案   getc( ) 從某一個檔案讀取一個字元   fprintf( ) 輸出資料至某檔案   fscanf( ) 從某檔案讀取資料   feof( ) 測試是否到了檔案結束位置   ferror( ) 測試檔案操作是否正常   fseek( ) 設定準備讀取檔案資料的位置   rewind( ) 將準備讀取檔案資料位置，設定在檔案起始位置   remove( ) 檔案的刪除    開檔 fopen( ) 用於開啟檔案,檔案在使用前是需先經過開啟動作的 使用格式如下\nFILE *fopen(char *filename, char *mode); 各項資料的定義如下所示：\n filename：檔案指標，指的是欲開啟的檔案名稱。 mode：檔案使用模式，指的是檔案被開啟之後，它的使用方式。  下面是檔案開啟之後，一般常使用的方式：\n   函數名稱 功能說明     \u0026ldquo;r\u0026rdquo; 開啟一個文字檔(text)，供程式讀取。   \u0026ldquo;w\u0026rdquo; 開啟一個文字檔(text)，供程式將資料寫入此檔案內。如果磁碟內不包含這個檔案，則系統會自行建立這個檔案。如果磁碟內包含這個檔案，則此檔案內容會被蓋過而消失。   \u0026ldquo;a\u0026rdquo; 開啟一個文字檔(text)，供程式將資料寫入此檔案的末端。如果此檔案不存在，則系統會自行建立此檔案。   \u0026ldquo;rb\u0026rdquo; 開啟一個二元檔(binary)，供程式讀取。   \u0026ldquo;wb\u0026rdquo; 開啟一個二元檔，供程式將資料寫入此檔案內。如果磁碟內不包含這個檔案，則系統會自行建立這個檔案。如果磁碟內包含這個檔案，此檔案內容會被蓋過而消失。   \u0026ldquo;ab\u0026rdquo; 開啟一個二元檔(binary)，供程式將資料寫入此檔案末端，如果此檔案不存在，則系統會自行建立此檔案。    關檔 fclose( ) 用於關閉檔案,如果fclose( )執行失敗，它的傳回值是非零值 在C語言中關閉檔案主要有兩個目的：\n 檔案在關閉前會將檔案緩衝區資料寫入磁碟檔案內，否則檔案緩衝區資料會遺失。 一個Ｃ語言程式，在同一時間可開啟的檔案數量有限，一般是20個，如果你的程式很大，要開啟超過20個檔案時，你必須將暫時不用的檔案關閉。  寫檔 fprintf( ) 主要目的是供你將資料，以格式化方式寫入某檔案內 使用格式如下\nfprintf( fp , \u0026ldquo;……\u0026rdquo; , ………); 此函數控制列印區和列印和列印變數區的使用,格式和printf( )使用格式相同. fprintf( )和printf( )兩者唯一的差別是，printf( )會將資料列印在螢幕上，而fprintf( )會將資料列印在某個檔案內。\n範例:\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *fp; int var,i; int sum = 0; float average; fp = fopen(\u0026#34;data1.txt\u0026#34;,\u0026#34;w\u0026#34;); /* open file pointer */ for ( i = 0; i \u0026lt; 5; i++ ) { printf(\u0026#34;\\1: input number %d here ==\u0026gt; \u0026#34;,i+1); scanf(\u0026#34;%d\u0026#34;,\u0026amp;var); sum += var; fprintf(fp,\u0026#34;%d\\n\u0026#34;,var); } average = (float) sum / 5.0; fprintf(fp,\u0026#34;\\2: The average is %6.2f\u0026#34;,average); fclose(fp); return 0; } 讀檔 fscanf( ) 主要的目的是讓我們從某個檔案讀取資料 使用格式如下\nfscanf( fp , \u0026ldquo;……\u0026rdquo; , ………); fscanf( )函數和scanf( )函數兩者之間最大的差別在，scanf( )函數主要用於從鍵盤輸入讀取資料，fscanf( )函數則是從fp檔案指標所指的檔案讀取資料。\n範例:\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *fp; int i,var; fp = fopen(\u0026#34;data1.txt\u0026#34;,\u0026#34;r\u0026#34;); /* open file pointer */ for ( i = 0; i \u0026lt; 5; i++ ) { fscanf(fp,\u0026#34;%d\u0026#34;,\u0026amp;var); printf(\u0026#34;%d\\n\u0026#34;,var); } fclose(fp); return 0; } 補充 putc( ) 主要功能是將一個字元寫入某檔案內， 使用格式: int putc( int ch, FILE *fp );\n此函數如果執行成功，它的傳回值是ch字元值，如果執行失敗，它的傳回值是EOF。且上述格式中，ch代表所欲輸出的字元，fp則是檔案指標。 下列為一個簡單建立一個檔案的程式應用。\n/* putc example: alphabet writer */ #include \u0026lt;stdio.h\u0026gt; int main () { FILE * pFile; char c; pFile=fopen(\u0026#34;alphabet.txt\u0026#34;,\u0026#34;wt\u0026#34;); for (c = \u0026#39;A\u0026#39; ; c \u0026lt;= \u0026#39;Z\u0026#39; ; c++) { putc (c , pFile); } fclose (pFile); return 0; } getc( ) 主要目的是某一個檔案中，讀取一個字元。 使用格式:\nint getc(FILE *fp);\n當執行getc( )函數成功時，傳回值是所讀取的字元，如果所讀取的是檔案結束字元，則此值是EOF，在stdio.h內，此值是 -1。\n#include \u0026lt;stdio.h\u0026gt;int main () { FILE * pFile; int c; pFile=fopen (\u0026#34;alphabet.txt\u0026#34;,\u0026#34;r\u0026#34;); if (pFile==NULL) perror (\u0026#34;Error opening file\u0026#34;); else { do { c = getc (pFile); printf(\u0026#34;%c\u0026#34;,c); } while (c != EOF); fclose (pFile); } return 0; } "});index.add({'id':61,'href':'/docs/summary/','title':"Summary",'content':""});index.add({'id':62,'href':'/docs/','title':"開卷",'content':"開卷  凡人若想要勝過天才，就只能化身為修羅。\n 當你打開了這本講義，恭喜你成為了藝術家！或許你會問：「為什麼是藝術家？不是工程師嗎？」原因很簡單，因為「Coding也是門藝術」，或許會有人覺得相當不服氣，「不就是寫幾行程式碼而已嗎？」正是因為能用幾行程式碼改變世界，才會稱他為「藝術」。在撰寫程式碼上，有許許多多需要瞭解、注意的事情。\n在這本講義中，集結了編者群的學習歷程，每個人都是從基礎一步一步走來，正如同翻閱這份講義的各位，我們期望讓這份講義，不只是冷冰冰的白紙黑字，理論與實作並進，透過課堂上的範例及課後的練習，堆起名為實力的巨牆，奠定資訊工程的基礎。\n參考文獻/書籍/網站   CPlusPlus.com  "});})();